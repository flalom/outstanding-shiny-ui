[
["index.html", "Outstanding User Interfaces with Shiny Welcome Disclaimer Is this book for me? Learning objectives Extra material Acknowledgements Packages", " Outstanding User Interfaces with Shiny David Granjon 2020-10-14 Welcome This book is still under active development and intended for a 2021 Q2 release in the R Series by Chapman &amp; Hall. Disclaimer This book is not an HTML/Javascript/CSS course and won’t make you become a web developer! Instead, it provides a survival kit to customize Shiny. I am sure however that readers will want to explore more about these topics. Is this book for me? Before going further, the reader must: Be comfortable with basic R structures and concepts, functional and object oriented programming (R6) Have solid knowledge of Shiny Basic knowledge in HTML and JavaScript is a plus but not mandatory. If you fulfill the above prerequisites, you should read this book if you answer yes to the following questions: Do you want to know how to develop shiny apps with a more professional look and feel? Have you ever wondered how to design new input widgets to unleash interactivity? Are you simply curious about what happens under the hood? Learning objectives This book will help you to: Manipulate Shiny tags from R to create custom layouts Harness the power of CSS and JavaScript to quickly design apps standing out from the pack Discover the steps to import and convert existing web frameworks like Bootstrap 4, framework7 Learn how Shiny internally deals with inputs Learn more about less documented Shiny mechanisms (websockets, sessions, …) Extra material This book may serve as material for workshops. See below a list of recent events. 0.0.1 e-Rum 2020 Novartis associates Mustapha Larbaoui and David Granjon gave a workshop entitled “Advanced User Interfaces for Shiny Developers” at the latest 2020 virtual e-Rum conference whose detailed agenda is available here. This two hours workshop takes a lot of inspiration on this book. An RStudio Cloud dedicated project is deployed here and slides are located here. 0.0.2 R/Pharma 2020 This books served as resource for the 2020 R/Pharma Unleash Shiny workshop held by John Coene, Colin Fay and David Granjon. Slides are available here and exercises accessible from here. This workshop expects an higher level than the e-Rum one. Acknowledgements I am very grateful to Douglas Robinson for proof reading the book and fixing many typos it contained A special thanks to my friends John and Victor for contributing to RinteRface Thanks to the eRum organizers for inviting me to the virtual e-Rum2020 conference RinteRface and this book won’t exist without the amazing R community. Thanks for their valuable feedback Packages library(shiny) ## Warning: package &#39;shiny&#39; was built under R version 3.6.2 library(shinydashboard) ## ## Attaching package: &#39;shinydashboard&#39; ## The following object is masked from &#39;package:graphics&#39;: ## ## box library(cascadess) ## ## Attaching package: &#39;cascadess&#39; ## The following object is masked from &#39;package:graphics&#39;: ## ## text library(htmltools) ## Warning: package &#39;htmltools&#39; was built under R version 3.6.2 library(purrr) ## Warning: package &#39;purrr&#39; was built under R version 3.6.2 library(magrittr) ## ## Attaching package: &#39;magrittr&#39; ## The following object is masked from &#39;package:purrr&#39;: ## ## set_names library(ggplot2) ## Warning: package &#39;ggplot2&#39; was built under R version 3.6.2 ## ## Attaching package: &#39;ggplot2&#39; ## The following object is masked from &#39;package:cascadess&#39;: ## ## margin library(thematic) library(fresh) library(testthat) ## ## Attaching package: &#39;testthat&#39; ## The following objects are masked from &#39;package:magrittr&#39;: ## ## equals, is_less_than, not ## The following object is masked from &#39;package:purrr&#39;: ## ## is_null library(jstools) library(scales) ## Warning: package &#39;scales&#39; was built under R version 3.6.2 ## ## Attaching package: &#39;scales&#39; ## The following object is masked from &#39;package:purrr&#39;: ## ## discard library(dplyr) ## Warning: package &#39;dplyr&#39; was built under R version 3.6.2 ## ## Attaching package: &#39;dplyr&#39; ## The following object is masked from &#39;package:testthat&#39;: ## ## matches ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union library(apexcharter) ## Warning: package &#39;apexcharter&#39; was built under R version 3.6.2 library(shinyWidgets) ## Warning: package &#39;shinyWidgets&#39; was built under R version 3.6.2 "],
["intro.html", "Chapter 1 Introduction 1.1 Why another Shiny related book? 1.2 Book structure 1.3 Code structure 1.4 Preliminary exercices", " Chapter 1 Introduction 1.1 Why another Shiny related book? There are various Shiny focused resources introducing basic as well as advanced topics such as modules and Javascript/R interactions, however, handling advanced user interfaces design was never an emphasis. Clients often desire custom templates, yet this generally exceeds core features of Shiny (not out of the box). Generally, R App developers lack a significant background in web development and often find this requirement overwhelming. It was this sentiment that motivated writing this book, namely to provide readers the necessary knowledge to extend Shiny’s layout, input widgets and output elements. This project officially started at the end of 2018 but was stopped when Joe Cheng revealed the upcoming Mastering Shiny Book. Fortunately, the later, does not cover a lot about the customization of Shiny user interfaces. Besides, this book may constitute a good complement to the work in progress Engineering Production-Grade Shiny Apps by the ThinkR team, where the link between Shiny and CSS/JavaScript is covered. For a deep dive into JavaScript and R interactions, the upcoming book by John Coene covers topics like htmlWidgets, interactive documents and computations. 1.2 Book structure This book is organized into six parts. Part 1 demonstrates the link between Shiny and the classic web languages like HTML, CSS and JavaScript. We finish by exploring the dependencies behind Shiny (Bootstrap, jQuery, …) In part 2, we dive into the {htmltools} (Cheng et al. 2020) package, providing functions to create and manipulate HTML tags from R as well as manage web dependencies Part 3 contains chapters dedicated to the Shiny input system where we highlight some partially hidden features like websockets. This part starts with a JavaScript introduction that might be skipped if necessary! Part 4 focuses on the development of a new template for Shiny by demonstrating examples from the {tablerDash} (Granjon 2020) package, being a serious refreshment to {shinydashboard} (Chang and Borges Ribeiro 2018). These, and more may be explored further as part of the RinteRface project. Part 5 focuses on CSS and SASS, showcasing examples from the R community like {fresh} Perrier and Meyer (2020b)], to beautify apps with only few lines of code Part 6 dives into mobile web development through a practical study involving the {shinyMobile} package (Granjon, Perrier, and Rudolf 2020) 1.3 Code structure This book has a side package containing all the necessary material to run the code without having to reload each previous snippet. remotes::install_github(&quot;DivadNojnarg/outstanding-shiny-ui-code &quot;) It covers Chapters 9, 10 and the whole Practice section. There is another good reason for this package: provide a robust method to bundle JavaScript/CSS code along side any shiny app. Indeed, it is quite tempting to proceed as below: ui &lt;- fluidPage( tags$script( &quot;$(function() { Shiny.addCustomMessageHandler(&#39;hello&#39;, function(message) { alert(message); }); }); &quot; ), actionButton(&quot;go&quot;, &quot;Send&quot;) ) server &lt;- function(input, output, session) { observeEvent(input$go, { session$sendCustomMessage(&quot;hello&quot;, message = &quot;plop&quot;) }) } shinyApp(ui, server) It is fine if the app purpose is a simple demonstration. In our case, since we aim at providing reusable template elements, we need a better approach, that will be described later. 1.4 Preliminary exercices Before starting with technical details, we propose to play a little game. Among all the images shown, what are the ones corresponding to shiny apps? References "],
["web-intro.html", "Chapter 2 Shiny and the Web 2.1 Shiny generates HTML code from R 2.2 HTML 101", " Chapter 2 Shiny and the Web Shiny allows the development of web applications with R in minutes. Let’s face it: this is quite mind blowing! While this may not be a production ready app, it will still be a fully functional, working prototype. Believe me, doing a web application with pure HTML/CSS and JavaScript is more difficult, especially for someone with a non-web developer background. library(shiny) 2.1 Shiny generates HTML code from R Let’s start with a little exercise: Run the following code: p(&quot;Hello World&quot;) Copy and paste this code to the R console. What do you observe? Notice the output format is an example of an HTML tag. The p function generates HTML (see chapter 4). The main difference between HTML tags and Shiny tags is the absence of closing tag for Shiny. For instance, in raw HTML, we expect &lt;p&gt; to be closed by &lt;/p&gt;. In Shiny, we only call p(...), where ... may be attributes like class/id or children tags. For a R developer, being able to generate HTML code from R allows to remain focused on the main task instead of the web development burdens. As stated in the general introduction 1, a production app sometimes needs to custom elements that are not contained or hidden in Shiny’s core. Is a Shiny app less customizable than a classic web app? Not at all! Under the hood, Shiny has its own engine to build HTML tags, through R, meaning that all HTML elements are available. You may also include any custom JavaScript or CSS code. 2.2 HTML 101 This chapter provides a short introduction to the 3 main web languages, namely HTML, CSS and JavaScript. The following content is crucial to understand part 4 about HTML generation from R. 2.2.1 HTML Basics HTML (Hypertext Markup Language) is derived from SGML (Standard Generalized markup Language). An HTML file contains tags that may be divided into 2 categories: paired-tags: the text is inserted between the opening and the closing tag closing-tags &lt;!-- paired-tags --&gt; &lt;p&gt;&lt;/p&gt; &lt;div&gt;&lt;/div&gt; &lt;!-- self-closing tags --&gt; &lt;iframe/&gt; &lt;img/&gt; &lt;input/&gt; &lt;br/&gt; Tags may be divided into 3 categories, based on their role: structure tags: they constitute the skeleton of the HTML page (&lt;title&gt;&lt;/title&gt;, &lt;head&gt;&lt;/head&gt;, &lt;body&gt;&lt;/body&gt;) control tags: script, inputs and buttons (and more). Their role is to include external resources, provide interactivity with the user formatting tags: to control the size, font of the wrapped text Finally, we distinguish block and inline elements: block elements may contain other tags and take the full width (block or inline). &lt;div&gt;&lt;/div&gt; is the most commonly used block element. All elements of a block are printed on top of each others inline elements (for instance &lt;span&gt;&lt;/span&gt;, &lt;a&gt;&lt;/a&gt;) are printed on the same line. They can not contain block tags but may contain other nested inline tags. In practice, we often see &lt;a&gt;&lt;span&gt;&lt;/span&gt;&lt;/a&gt; inline-block elements allow to insert block element in an inline Consider the following example. This is clearly a bad use of HTML conventions since an inline tag can not host block elements. &lt;span&gt; &lt;div&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/span&gt; Importantly, &lt;div&gt; and &lt;span&gt; don’t have any semantic meaning, contrary to &lt;header&gt; and &lt;footer&gt;, which allow to structure the HTML page. 2.2.2 Tag attributes Attributes are text elements allowing to specify some properties of the tag. For instance for a link tag (&lt;a&gt;&lt;/a&gt;), we actually expect more than just the tag itself: a target url and how to open the new page … In all previous examples, tags don’t have any attributes. Yet, there exist a large range of attributes and we will only see 2 of them for now (the reason is that these are the most commonly used in CSS and JavaScript): class: may be shared between multiple tags id: each must be unique &lt;div class=&quot;awesome-item&quot; id=&quot;myitem&quot;&gt;&lt;/div&gt; &lt;!-- the class awesome-item may be applied to multiple tags --&gt; &lt;span class=&quot;awesome-item&quot;&gt;&lt;/span&gt; Both attributes are widely used by CSS and JavaScript (see Chapter 7 with the jQuery selectors) to apply a custom style to a web page. Class attributes apply to multiple elements, however the id attribute is restricted to only one item. Interestingly, there exists another attribute category, know as non-standard attributes like data-toggle. We will see them later in the book (see Chapter 13). 2.2.3 The simplest HTML skeleton An HTML page is a collection of tags which will be interpreted by the web browser step by step. The simplest HTML page may be defined as follows: &lt;!DOCTYPE HTML&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;!-- head content here --&gt; &lt;title&gt;A title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- body content here --&gt; &lt;/body&gt; &lt;/html&gt; &lt;html&gt; is the may wrapper &lt;head&gt; and &lt;body&gt; are the 2 main children &lt;head&gt; contains dependencies like styles and JavaScript files (but not only), &lt;body&gt; contains the page content and it is displayed on the screen. We will see later that JavaScript files are often added just before the end of the &lt;body&gt;. Only the body content is displayed on the screen! W3C validation imposes at list a title tag in the head section and a lang attribute to the html tag! Let’s write the famous Hello World in HTML: &lt;!DOCTYPE HTML&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;!-- head content here --&gt; &lt;title&gt;A title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello World&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; In order to preview this page in a web browser, you need to save the above snippet to a script hello-world.html and double-click on it. It will open with your default web browser. Below is how we would do with a Shiny app, only for demonstration purpose (static HTML would be enough if no user interaction is required). ui &lt;- fluidPage(p(&quot;Hello World&quot;)) server &lt;- function(input, output, session) {} shinyApp(ui, server) From outside, it looks identical even though we’ll see in Chapter 3 that this simple app actually contains much more HTML than our previous example. 2.2.4 About the Document Object Model (DOM) The DOM stands for “Document Object Model” and is a convenient representation of the html document. There actually exists multiple DOM types, namely DOM-XML and DOM-HTML but we will only focus on the latter. If we consider the last example (Hello World), the associated DOM tree may be inspected in Figure 2.1. 2.2.4.1 Visualizing the DOM with the HTML inspector Below, we introduce a tool that will facilitate our exploration of beautiful shiny user interfaces. In this section, we restrict the description to the first panel of the HTML inspector.1 This feature is available in all web browsers, however for demonstration purposes, we will only focus on the Chrome DevTools. It may be opened: After a right click and selecting inspect After clicking on F12 (windows), fn + F12 on Mac (or Command+Option+C) In the following: Open the hello-world.html example with Chrome Right-click to open the HTML inspector (developer tools must be enabled if it is not the case) The HTML inspector is a convenient tool to explore the structure of the current HTML page. On the left-hand side, the DOM tree is displayed where we clearly see that &lt;html&gt; is the parent of &lt;head&gt; and &lt;body&gt;. &lt;body&gt; has also 1 child, that is &lt;p&gt;. We may preview any style (CSS) associated with the selected element on the right panel as well as Event Listeners (JavaScript), which will be discussed later in the book. FIGURE 2.1: Inspection of the DOM in the Hello World example 2.2.4.2 HTML Inspector 101 In the following, we enumerate key features of the inspector Elements tab. In addition to explore the HTML structure, the inspector allows to: Dynamically change CSS at run time Debug JavaScript code (put break points, …) Run JavaScript code from the console. Monitor any error or warning that may prevent your app or website from properly working Another important feature is the ability to switch between different devices, especially mobile platforms and to do a global performance audit with Google LightHouse. The book from Colin Fay et al. details the most relevant elements for Shiny app development. We propose at set of quick exercises to review the most important HTML inspector capabilities that are commonly needed during Shiny app customization. We consider the app already defined above: ui &lt;- fluidPage(p(&quot;Hello World&quot;)) server &lt;- function(input, output, session) {} shinyApp(ui, server) 2.2.4.2.1 Altering the DOM structure Run the Hello World app, right click on the only text element and click on inspect Notice we could have done similarly by clicking on the very top left corner Inspect icon (Command + maj + C for Mac) and hovering over the Hello World text You should see a result similar to Figure 2.2, the Inspect icon being in blue. The selected element is highlighted and a white box displays the main CSS properties like text-color, font-size, margins, as well as accessibility parameters. FIGURE 2.2: Inspection of the p element in the Hello World example In the Elements panel, double click between the &lt;p&gt; and &lt;/p&gt; tags to edit the current text. Press enter when finished Let’s add some children to our p tag. Right click and select the Edit as HTML option. You may enter any valid HTML code inside. Don’t forget about some rules relative to inline and block tags (inline tags cannot contain block tags!!!) As depicted in Figure 2.3, we could have done a right click on the p tag to display more options like: Add/edit an attribute. You may try to add it a class class=\"awesome-text\" and an id id=\"only-text\" Delete the current tag (the return key would do it as well) Copy the element with all nested elements Only copy the outside HTML (ignore nested elements) Extract the CSS selector or JavaScript path (code to select the element): body &gt; div &gt; p and document.querySelector(\"body &gt; div &gt; p\"), respectively. These 2 features are extremely powerful as they save you time. Try to copy and paste document.querySelector(\"body &gt; div &gt; p\") in the JavaScript console at the bottom of the inspector window. It returns the selected HTML element, as shown in Figure 2.4! Amazing isn’ it? Hide the element Force a specific state. For instance buttons may be active, inactive FIGURE 2.3: Modifications of the p element in the Hello World example FIGURE 2.4: Extract the JavaScript path to select the p element Whenever you are looking for a specific tag in a more complex page, the search tag option is a game changer (Ctrl + F on Windows, command + F within the Elements tab on a Mac). See Figure 2.5. FIGURE 2.5: Search for element having the “awesome-text” class Finally, the inspector toolkit allows to reorder DOM elements with a rather intuitive drag and drop feature. I invite the reader to carefully explore those features as they will be crucial in the next chapters. 2.2.5 Preliminary introduction to CSS and JavaScript To introduce this section, I propose to look at the very first website, early in the 90’s (August 1991 exactly). From an aesthetic point of view (see Figure 2.6), this is far from what we can observe today as shown in Figure 2.7. FIGURE 2.6: World wide web website FIGURE 2.7: RinteRface website: https://rinterface.com How can we explain that difference? One of the main reason is the absence of CSS (Cascading Style Sheet) since the first CSS release only appeared in December 1996, that is 5 years later than the first web site publication. CSS allows to deeply customize the appearance of any web page by changing colors, fonts, margins and much more. We acknowledge, the role of JavaScript cannot be demonstrated through the previous example. Yet its impact is as important as CSS, so that it is now impossible to dissociate HTML, CSS and JavaScript. 2.2.5.1 HTML and CSS CSS (Cascading Style Sheets) changes the style of HTML tags by targeting specific classes or ids. For instance, if we want all p tags to have red color we will use: p { color: red; } To include CSS in an HTML page, we use the &lt;style&gt; tag as follows: &lt;!DOCTYPE HTML&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; p { color: red; } &lt;/style&gt; &lt;title&gt;A title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello World&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; You may update the hello-world.html script and run it in your web-browser to see the difference. The example may be slight, but shows how we may control the look and feel of the display. In a development context, we will see later that css files may so big that it is better to include them in external files. Let’s build a shiny app that does similar things. As a reminder, you may use tags$style to include small pieces of CSS in your app: ui &lt;- fluidPage( tags$style(&quot;p { color: red;}&quot;), p(&quot;Hello World&quot;) ) server &lt;- function(input, output, session) {} shinyApp(ui, server) 2.2.5.2 Modifying CSS with the HTML inspector 2.2.5.2.1 Add inline properties Run the previous app, right click the p element and open the inspector. In the Styles tab, notice the element.style section. This is to define inline new CSS rules for the selected item. Let’s add 2 rules by clicking inside the element.style container: border-style: dashed. Indicates we want a box with dashed border border-color: .... To set a border color After typing enter, the inline CSS is automatically added in the tag element. As you can see, CSS is rather self-explanatory. You probably noticed the auto suggestion feature while typing a property, as shown in Figure 2.8. Don’t worry if everything seems overwhelming at the moment. We’ll dedicate an entire part to CSS later in the book. FIGURE 2.8: Edit CSS with Chrome DevTools 2.2.5.2.2 View local changes Whenever playing around with a web page style or a shiny app, it may be good to have an overview of all changes when you are satisfied about the new design. Run the previous shiny app example and open the inspector In the Styles tab, add some new CSS properties to the first p element set of rules Once done press enter and click on the file name located at the top-right corner of the property box This opens the Sources tab. In the left sidebar, right click on the file name (index) and select Local Modifications This opens a Git like diff panel called Changes where you can review any change and see the previous values. If you refresh the page, you will loose every local change, unless the persistent authoring feature is active FIGURE 2.9: Review all CSS changes To get a deeper understanding of the different CSS options please refer to the Google documentation. 2.2.5.3 HTML and JavaScript You will see how quickly/seamlessly you may add awesome features to your shiny app. In the following example, we defined the changeColor function that targets the element having hello id and change its color property to green. The HTML element has an onClick attribute that triggers the changeColor function each time the button is clicked. &lt;!DOCTYPE HTML&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;style type=&quot;text/css&quot;&gt; p { color: red; } &lt;/style&gt; &lt;script language=&quot;javascript&quot;&gt; // displays an alert alert(&#39;Click on the Hello World text!&#39;); // change text color function changeColor(color){ document.getElementById(&#39;hello&#39;).style.color = &quot;green&quot;; } &lt;/script&gt; &lt;title&gt;A title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- onclick attributes applies the JavaScript function changeColor define above --&gt; &lt;p id=&quot;hello&quot; onclick=&quot;changeColor(&#39;green&#39;)&quot;&gt;Hello World&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; In few lines of code, you can change the color of the text. This is only the beginning! We see below that the process is not dramatically different in a Shiny app. We wrap our custom JavaScript in the tags$script function (prefer external scripts to add more code), as below: ui &lt;- fluidPage( tags$script( &quot;alert(&#39;Click on the Hello World text!&#39;); // change text color function changeColor(color){ document.getElementById(&#39;hello&#39;).style.color = &#39;green&#39;; } &quot; ), p(id = &quot;hello&quot;, onclick=&quot;changeColor(&#39;green&#39;)&quot;, &quot;Hello World&quot;) ) server &lt;- function(input, output, session) {} shinyApp(ui, server) As demonstrated above, developing a shiny app is basically building a website from R and is completely compatible with the web languages, that is CSS and JavaScript. Sections 5 and 9 present more robust tools and concepts to extend Shiny. As shown in Figure 2.1, the inspector also has tools to debug JavaScript code as demonstrated in 7.6, inspect files, run performances audit, inspect websocket activity (see section 8.1).↩︎ "],
["web-dependencies.html", "Chapter 3 Discover Shiny dependencies 3.1 Introduction 3.2 Bootstrap 3.3 jQuery, DOM manipulation 3.4 Data formating 3.5 Custom dependencies 3.6 Exercise", " Chapter 3 Discover Shiny dependencies 3.1 Introduction If Shiny creates HTML code for us, it is not enough to design a beautiful working app with user interactions. As shown earlier, all modern web sites and apps have a lot of CSS and JavaScript under the hood. Let’s explore these elements in the following exercise. The simplest Shiny layout is the fluidPage. The shinyapp predefined Rstudio snippet will create a basic app skeleton (type shinyapp in RStudio IDE): ui &lt;- fluidPage( p(&quot;Hello World&quot;) ) server &lt;- function(input, output) {} shinyApp(ui, server) At first glance, the page only contains text. Wait … are you sure about this? Let’s run the above example and open the HTML inspector introduced in 2.2. Results are displayed on Figure 3.1. FIGURE 3.1: Shiny dependencies Click on “Open in Browser” Open the HTML inspector Locate the &lt;head&gt; tag Uncollapse it and search for the script containing application/html-dependencies List all dependencies We see in the head section (delimited by &lt;head&gt;&lt;/head&gt;) that Shiny has four dependencies: json2 jQuery 3.4.1 shiny (custom JavaScript and CSS) Bootstrap 3.4.1 (JavaScript and CSS) + other files (html5shiv, respond) 3.2 Bootstrap According to the gitstar ranking, Bootstrap comes at the 7th place (144563 stars) and 22th place for repositories and organization, respectively. It has been first released in 2011 and will welcome the fifth version in few months. It provides plug and play layout and interactive elements such as tabs, navigation bars, tooltips, popovers and many input (forms), which is rather convenient since it avoids writing a large amount of CSS/JavaScript that would bring more complexity. The first release of Shiny was shipped with Bootstrap 2. Shiny currently relies on Bootstrap 3 since v0.11, while a lot of efforts are being made to provide a Bootstrap 4 compatibility, essentially through the bootstraplib R package. One of the great advantage of using Bootstrap is the responsiveness of the design that can work either on desktop or mobile, even though advanced user likely prefer other specialized libraries like Framework7 or onsenUI to develop native looking apps. Bootstrap 3 relies on the grid layout system that allows to efficiently organize the content in row and columns. For instance the fluidRow and column Shiny functions leverage the Bootstrap grid to control how elements are displayed in a page. 3.3 jQuery, DOM manipulation jQuery allows to perform DOM manipulation, that is interacting with HMTL elements, in a more user-friendly manner than with pure JavaScript. At that step, you might not be familiar with JavaScript nor jQuery. Don’t worry chapter 7 will expose the basics. Below is a comparison on how you would select a button HTML element with both technologies. I am sure you’ll notice how jQuery2 is more intuitive than JavaScript. Javascript: var btn = document.getElementById(&#39;mybutton&#39;); // select the button btn.addEventListener(&#39;click&#39;, function() { // action + consequences alert(&#39;You clicked me!&#39;); // action }); jQuery: $(&#39;#mybutton&#39;).on(&#39;click&#39;, function() { alert(&#39;You clicked me!&#39;); }); 3.4 Data formating json2 is a library to handle the JSON data format (JavaScript Object Notation). We will see in section 8.1 of Chapter 8 that the R / JS communication involves data exchange and given that data structures are not the same in R and JS, there must be a way to ensure the translation. This is done through the jsonlite package that allows to transform JSON objects in R objects with jsonlite::fromJSON and inversely with jsonlite::toJSON. Shiny automatically handles the process and it works well most of the time! 3.5 Custom dependencies The last dependency contains custom JS and CSS code necessary for Shiny to work, that is: Fine tuning the layout Registering input/output Handling every single input/output action Initializing and controlling the R/JS communication Handling alerts/modals/notifications … Part 8.3, 9, 10 and 16 showcase the most important elements of those custom files. TO DO: link to CSS part 3.6 Exercise In the following exercise, we consider a more complex app with a slider as well as a plot output. Run the app runExample(\"01_hello\") Open the HTML inspector Delete the bootstrap.min.css and ion.rangeSlider.css Conclusions To sump up, all these libraries are necessary to make Shiny what it is! In Chapter 5, we explore tools to manage HTML dependencies. In Chapter 16.4.1, we study a special case to insert dependencies during the app runtime. Let’s move to the next part to discover the internal engine that creates HTML code from R! The next iteration of Bootstrap, namely Bootstrap 5 completely abandons jQuery for vanilla JavaScript. The main reason is to lighten the Bootstrap code.↩︎ "],
["htmltools-overview.html", "Chapter 4 htmltools overview 4.1 Writing HTML Tags from R 4.2 Notations 4.3 Adding new tags 4.4 Alternative way to write tags 4.5 Playing with tags 4.6 Exercises", " Chapter 4 htmltools overview {htmltools} (Cheng et al. 2020) is a R package designed to: Generate HTML tags from R Handle web dependencies (see chapter 5) Historically, {htmltools} was extracted out of {shiny} (Chang et al. 2020) to be able to extend it, that is developing custom HTML tags, importing extra dependencies from the web. That’s why, both packages have many common functions! At the moment, {htmltools} does not have any user guide, although being a key package for all web things! 4.1 Writing HTML Tags from R {htmltools} provides the necessary functions to write HTML tags that were introduced in Chapter 2.2. In R, it is even more convenient than raw HTML since their is no opening/closing tag, a simple function call instead: div() does produce an HTML &lt;div&gt;&lt;/div&gt; tag. Inside the function call, all named elements will become attributes, whereas unnamed elements will become children. In some cases, tags may have empty attributes like &lt;input disabled&gt;. In that case, the corresponding R code is input(disabled = NA). 4.2 Notations Whether to use tags$div or div depends if the tag is exported by default. For instance, you could use htmltools::div but not htmltools::nav since nav does not have a dedicated function (only for p, h1, h2, h3, h4, h5, h6, a, br, div, span, pre, code, img, strong, em, hr). Rather prefer htmltools::tags$nav. Alternatively, there exists a function (in shiny and htmltools) called withTags. Wrapping your code in this function allows code like this withTags(nav(), ...) instead of tags$nav(), thereby omitting the tags$ prefixes. If you had to gather multiple tags together, choose tagList() over list(), although the HTML output is the same. The first has the shiny.tag.list class in addition to list. Package like {golem} (Guyader et al. 2020) (see also http://golemverse.org) allows to test if an R object is a tag list. In this case, using a list would cause the test fail. 4.3 Adding new tags The tag function allows to add extra HTML tags not already defined. You may use it as follows: customTag &lt;- tag(&quot;test&quot;, list(class = &quot;test&quot;, p(&quot;Custom Tag&quot;))) str(customTag) ## List of 3 ## $ name : chr &quot;test&quot; ## $ attribs :List of 1 ## ..$ class: chr &quot;test&quot; ## $ children:List of 1 ## ..$ :List of 3 ## .. ..$ name : chr &quot;p&quot; ## .. ..$ attribs : Named list() ## .. ..$ children:List of 1 ## .. .. ..$ : chr &quot;Custom Tag&quot; ## .. ..- attr(*, &quot;class&quot;)= chr &quot;shiny.tag&quot; ## - attr(*, &quot;class&quot;)= chr &quot;shiny.tag&quot; customTag Custom Tag Good practice is to check whether the created tag is in line with the HTML validation rules. 4.4 Alternative way to write tags {htmltools} comes with the HTML() function that you can feed with raw HTML: HTML(&#39;&lt;div&gt;Blabla&lt;/div&gt;&#39;) # will render exactly like div(&quot;Blabla&quot;) # but there class is different class(HTML(&#39;&lt;div&gt;Blabla&lt;/div&gt;&#39;)) class(div(&quot;Blabla&quot;)) You will not be able to use tag related functions, as in the following parts. Therefore, I strongly recommend using R and not mixing HTML in R. Interestingly, if you want to convert raw HTML to R code, there is a Shiny App developed by Alan Dipert from RStudio, namely html2R. There are some issues, non standard attributes (like data-toggle) are not correctly processed but there are solutions. This will save you precious time! A more recent approach is developed in section 17 and has be internally used to develop some of the RinteRface templates. 4.5 Playing with tags 4.5.1 Tags structure A tag is defined by: A name such as span, div, h1 … tag$name Some attributes, which can be accessed with tag$attribs Children, which you can be accessed with tag$children A class, namely shiny.tag For instance: # create the tag myTag &lt;- div( class = &quot;divclass&quot;, id = &quot;first&quot;, h1(&quot;Here comes your baby&quot;), span(class = &quot;child&quot;, id = &quot;baby&quot;, &quot;Crying&quot;) ) # access its name myTag$name # access its attributes (id and class) myTag$attribs # access children (returns a list of 2 elements) myTag$children # access its class class(myTag) How to modify the class of the second child? second_children &lt;- myTag$children[[2]] second_children$attribs$class &lt;- &quot;adult&quot; myTag # This is not working ... Why is this not working? By assigning myTag$children[[2]] to second_children, second_children$attribs$class &lt;- \"adult\" modifies the class of the copy and not the original object. Thus we do: myTag$children[[2]]$attribs$class &lt;- &quot;adult&quot; myTag 4.5.2 Useful functions for tags {htmltools} and {shiny} have powerful functions to seamlessly manipulate tags. 4.5.2.1 Add attributes tagAppendAttributes: this function allows to add a new attribute to the current tag. For instance, assuming we created a div without any id attribute: mydiv &lt;- div(&quot;Where is my brain&quot;) mydiv &lt;- tagAppendAttributes(mydiv, id = &quot;here_it_is&quot;) You can pass as many attributes as you want, including non standard attributes such as data-toggle (see Bootstrap 3 tabs for instance): mydiv &lt;- tagAppendAttributes(mydiv, list(`data-toggle` = &quot;tabs&quot;, class = &quot;myclass&quot;)) # even though you could proceed as follows but this requires 2 steps mydiv$attribs[[&quot;data-toggle&quot;]] &lt;- &quot;tabs&quot; mydiv$attribs$class &lt;- &quot;myclass&quot; 4.5.2.2 Check if tag has specific attribute tagHasAttribute: to check if a tag has a specific attribute # I want to know if div has a class mydiv &lt;- div(class = &quot;myclass&quot;) has_class &lt;- tagHasAttribute(mydiv, &quot;class&quot;) has_class # if you are familiar with %&gt;% has_class &lt;- mydiv %&gt;% tagHasAttribute(&quot;class&quot;) has_class In practice, this function is useful when testing tag elements as shown in chapter 14. 4.5.2.3 Get all attributes tagGetAttribute: to get the value of the targeted attributes, if it exists, otherwise NULL. mydiv &lt;- div(class = &quot;test&quot;) # returns the class tagGetAttribute(mydiv, &quot;class&quot;) # returns NULL tagGetAttribute(mydiv, &quot;id&quot;) 4.5.2.4 Set child/children tagSetChildren allows to create children for a given tag. For instance: mydiv &lt;- div(class = &quot;parent&quot;, id = &quot;mother&quot;, &quot;Not the mama!!!&quot;) # mydiv has 1 child &quot;Not the mama!!!&quot; mydiv children &lt;- lapply(1:3, span) mydiv &lt;- tagSetChildren(mydiv, children) # mydiv has 3 children, the first one was removed mydiv Notice that tagSetChildren removes all existing children. Below we see another set of functions to add children while conserving existing ones. 4.5.2.5 Add child or children tagAppendChild and tagAppendChildren: add other tags to an existing tag. Whereas tagAppendChild only takes one tag, you can pass a list of tags to tagAppendChildren. mydiv &lt;- div(class = &quot;parent&quot;, id = &quot;mother&quot;, &quot;Not the mama!!!&quot;) otherTag &lt;- span(&quot;I am your child&quot;) mydiv &lt;- tagAppendChild(mydiv, otherTag) 4.5.2.6 Build your own functions You might wonder why there is no tagRemoveChild or tagRemoveAttributes. Let’s look at the tagAppendChild tagAppendChild &lt;- function (tag, child) { tag$children[[length(tag$children) + 1]] &lt;- child tag } Below we write the tagRemoveChild, where tag is the target and n is the position to remove in the list of children: mydiv &lt;- div(class = &quot;parent&quot;, id = &quot;mother&quot;, &quot;Not the mama!!!&quot;, span(&quot;Hey!&quot;)) # we create the tagRemoveChild function tagRemoveChild &lt;- function(tag, n) { # check if the list is empty if (length(tag$children) == 0) { stop(paste(tag$name, &quot;does not have any children!&quot;)) } tag$children[n] &lt;- NULL tag } mydiv &lt;- tagRemoveChild(mydiv, 1) mydiv When defining the tagRemoveChild, we choose [ instead of [[ to allow to select multiple list elements: mydiv &lt;- div(class = &quot;parent&quot;, id = &quot;mother&quot;, &quot;Not the mama!!!&quot;, &quot;Hey!&quot;) # fails `[[`(mydiv$children, c(1, 2)) # works `[`(mydiv$children, c(1, 2)) Alternatively, we could also create a tagRemoveChildren function. Also notice that the function raises an error if the provided tag does not have children. The tagAppendChild is not able to insert at a specific position. We could draft the tagInsertChild building on top of the base R append function: tagInsertChild &lt;- function(tag, child, position) { tag$children &lt;- append(tag$children, list(child), position - 1) tag } tagInsertChild(p(span(&quot;hello&quot;)), a(), 1) tagInsertChild(p(span(&quot;hello&quot;)), a(), 2) 4.5.3 Other functions The Golem package written by thinkr contains neat functions to edit your tags. Particularly, the tagRemoveAttributes: tagRemoveAttributes &lt;- function(tag, ...) { attrs &lt;- as.character(list(...)) for (i in seq_along(attrs)) { tag$attribs[[ attrs[i] ]] &lt;- NULL } tag } mydiv &lt;- div(class = &quot;test&quot;, id = &quot;coucou&quot;, &quot;Hello&quot;) tagRemoveAttributes(mydiv, &quot;class&quot;, &quot;id&quot;) 4.5.4 Conditionally set attributes Sometimes, you only want to set attributes under specific conditions. my_button &lt;- function(color = NULL) { tags$button( style = paste(&quot;color:&quot;, color), p(&quot;Hello&quot;) ) } my_button() This example will not fail but having style=\"color: \" is not clean. We may use conditions: my_button &lt;- function(color = NULL) { tags$button( style = if (!is.null(color)) paste(&quot;color:&quot;, color), p(&quot;Hello&quot;) ) } my_button(&quot;blue&quot;) my_button() In this example, style won’t be available if color is not specified. 4.5.5 Using %&gt;% While doing a lot of manipulation for a tag, if you don’t need to create intermediate objects, this is a good idea to use %&gt;% from magrittr: div(class = &quot;cl&quot;, h1(&quot;Hello&quot;)) %&gt;% tagAppendAttributes(id = &quot;myid&quot;) %&gt;% tagAppendChild(p(&quot;some extra text here!&quot;)) The pipe syntax is overall easier to follow and read. 4.5.6 Programmatically create children elements Assume you want to create a tag with three children inside: div( span(1), span(2), span(3), span(4), span(5) ) The structure is correct but imagine if you had to create 1000 span or fancier tag. The previous approach is not consistent with DRY programming. lapply function will be useful here (or the purrr map family): # base R div(lapply(1:5, function(i) span(i))) # purrr + %&gt;% map(1:5, function(i) span(i)) %&gt;% div() 4.6 Exercises 4.6.1 Exercise 1: tags structure (5 minutes) Consider the following shiny tag: myTag &lt;- a( class = &quot;btn btn-large&quot;, type = &quot;button&quot;, span(class = &quot;child1&quot;, id = &quot;super-span&quot;, 1), span(class = &quot;child2&quot;, 2) ) myTag Inspect its structure. Hint: you may use str. Access its class using tagGetAttribute and another method of your choice. Modify the first child class to custom class. 4.6.2 Exercise 2: modifiying tags (5 minutes) Let us consider the following tag: temp &lt;- div(&quot;Hello World&quot;) (You may chain functions with %&gt;%) Replace its unique child by a(href = \"http://www.google.com\", \"click me!\"). Hint: tagSetChildren is your friend. Add 10 other span. Hint: tags may be programmatically generated with lapply or purrr::map. References "],
["htmltools-dependencies.html", "Chapter 5 Dependency utilities 5.1 The dirty approach 5.2 The clean approach 5.3 Another example: Importing HTML dependencies from other packages 5.4 Suppress dependencies 5.5 Insert Custom script in the head", " Chapter 5 Dependency utilities When creating a new template, you have to import custom HTML dependencies that are not available in shiny. Fortunately, this is not a problem with {htmltools}! 5.1 The dirty approach Let’s consider the following example. Since Bootstrap is one of the most popular HTML/CSS/JS framework to develop websites and web apps, we want to include a bootstrap 4 card in a shiny app. This example is taken from a RStudio Community question. The naive approach would be to include the HTML code directly in the app code. This approach is dirty since it is not easily re-usable by others. # we create the card function before my_card &lt;- function(...) { withTags( div( class = &quot;card border-success mb-3&quot;, div(class = &quot;card-header bg-transparent border-success&quot;), div( class = &quot;card-body text-success&quot;, h3(class = &quot;card-title&quot;, &quot;title&quot;), p(class = &quot;card-text&quot;, ...) ), div(class = &quot;card-footer bg-transparent border-success&quot;, &quot;footer&quot;) ) ) } # we build our app shinyApp( ui = fluidPage( fluidRow( column( width = 6, align = &quot;center&quot;, br(), my_card(&quot;blablabla. PouetPouet Pouet.&quot;) ) ) ), server = function(input, output) {} ) Unfortunately nothing is displayed. If you remember, this was expected since shiny does not contain bootstrap 4 dependencies and this card is a bootstrap 4 element. Don’t panic! Load the necessary css to display this card (if required, we could include the javascript as well). We could use either includeCSS(), tags$head(tags$link(rel = \"stylesheet\", type = \"text/css\", href = \"custom.css\")). See more here. shinyApp( ui = fluidPage( # load the css code includeCSS(path = &quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css&quot;), fluidRow( column( width = 6, align = &quot;center&quot;, br(), my_card(&quot;blablabla. PouetPouet Pouet.&quot;) ) ) ), server = function(input, output) {} ) The card may seem ugly but at least it is displayed. 5.2 The clean approach We will use the htmlDependency and attachDependencies functions from {htmltools}. The htmlDependency function takes the main arguments: the dependency name the version (useful to remember on which version it is built upon) a path to the dependency (can be a CDN or a local folder) script and stylesheet to respectively pass css and scripts # handle dependency card_css &lt;- &quot;bootstrap.min.css&quot; bs4_card_dep &lt;- function() { htmlDependency( name = &quot;bs4_card&quot;, version = &quot;1.0&quot;, src = c(href = &quot;https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/&quot;), stylesheet = card_css ) } We create the card tag and give it the bootstrap 4 dependency through the attachDependencies() function. In recent version of {htmltools}, we may simply use tagList(tag, deps) instead. # create the card my_card &lt;- function(...) { cardTag &lt;- withTags( div( class = &quot;card border-success mb-3&quot;, div(class = &quot;card-header bg-transparent border-success&quot;), div( class = &quot;card-body text-success&quot;, h3(class = &quot;card-title&quot;, &quot;title&quot;), p(class = &quot;card-text&quot;, ...) ), div(class = &quot;card-footer bg-transparent border-success&quot;, &quot;footer&quot;) ) ) # attach dependencies (old way) # htmltools::attachDependencies(cardTag, bs4_card_dep()) # simpler way tagList(cardTag, bs4_card_dep()) } We finally run our app: # run shiny app ui &lt;- fluidPage( title = &quot;Hello Shiny!&quot;, fluidRow( column( width = 6, align = &quot;center&quot;, br(), my_card(&quot;blablabla. PouetPouet Pouet.&quot;) ) ) ) shinyApp(ui, server = function(input, output) { }) With this approach, you can develop a package of custom dependencies that people could use when they need to add custom elements in shiny. 5.3 Another example: Importing HTML dependencies from other packages The {shinydashboard} package helps to design dashboards with shiny. In the following, we would like to integrate the box component in a classic Shiny App (without the dashboard layout). However, if you try to include the box tag, you will notice that nothing is displayed since Shiny does not have shinydashboard dependencies. Fortunately {htmltools} contains a function, namely findDependencies that looks for all dependencies attached to a tag. Before going further, let’s define the basic skeleton of a dashboard: shinyApp( ui = dashboardPage( dashboardHeader(), dashboardSidebar(), dashboardBody(), title = &quot;Dashboard example&quot; ), server = function(input, output) { } ) There are numerous details associated with shinydashboard that we will unfortunately not go into. If you are interested in learning more, please help yourself. The key point here is the main wrapper function dashboardPage. The fluidPage is another wrapper function that most are already familiar with. We apply findDependencies on dashboardPage. deps &lt;- findDependencies( dashboardPage( header = dashboardHeader(), sidebar = dashboardSidebar(), body = dashboardBody() ) ) deps ## [[1]] ## List of 10 ## $ name : chr &quot;font-awesome&quot; ## $ version : chr &quot;5.13.0&quot; ## $ src :List of 1 ## ..$ file: chr &quot;www/shared/fontawesome&quot; ## $ meta : NULL ## $ script : NULL ## $ stylesheet: chr [1:2] &quot;css/all.min.css&quot; &quot;css/v4-shims.min.css&quot; ## $ head : NULL ## $ attachment: NULL ## $ package : chr &quot;shiny&quot; ## $ all_files : logi TRUE ## - attr(*, &quot;class&quot;)= chr &quot;html_dependency&quot; ## ## [[2]] ## List of 10 ## $ name : chr &quot;bootstrap&quot; ## $ version : chr &quot;3.4.1&quot; ## $ src :List of 2 ## ..$ href: chr &quot;shared/bootstrap&quot; ## ..$ file: chr &quot;/Library/Frameworks/R.framework/Versions/3.6/Resources/library/shiny/www/shared/bootstrap&quot; ## $ meta :List of 1 ## ..$ viewport: chr &quot;width=device-width, initial-scale=1&quot; ## $ script : chr [1:3] &quot;js/bootstrap.min.js&quot; &quot;shim/html5shiv.min.js&quot; &quot;shim/respond.min.js&quot; ## $ stylesheet: chr &quot;css/bootstrap.min.css&quot; ## $ head : NULL ## $ attachment: NULL ## $ package : NULL ## $ all_files : logi TRUE ## - attr(*, &quot;class&quot;)= chr &quot;html_dependency&quot; ## ## [[3]] ## List of 10 ## $ name : chr &quot;AdminLTE&quot; ## $ version : chr &quot;2.0.6&quot; ## $ src :List of 1 ## ..$ file: chr &quot;/Library/Frameworks/R.framework/Versions/3.6/Resources/library/shinydashboard/AdminLTE&quot; ## $ meta : NULL ## $ script : chr &quot;app.min.js&quot; ## $ stylesheet: chr [1:2] &quot;AdminLTE.min.css&quot; &quot;_all-skins.min.css&quot; ## $ head : NULL ## $ attachment: NULL ## $ package : NULL ## $ all_files : logi TRUE ## - attr(*, &quot;class&quot;)= chr &quot;html_dependency&quot; ## ## [[4]] ## List of 10 ## $ name : chr &quot;shinydashboard&quot; ## $ version : chr &quot;0.7.1&quot; ## $ src :List of 1 ## ..$ file: chr &quot;/Library/Frameworks/R.framework/Versions/3.6/Resources/library/shinydashboard&quot; ## $ meta : NULL ## $ script : chr &quot;shinydashboard.min.js&quot; ## $ stylesheet: chr &quot;shinydashboard.css&quot; ## $ head : NULL ## $ attachment: NULL ## $ package : NULL ## $ all_files : logi TRUE ## - attr(*, &quot;class&quot;)= chr &quot;html_dependency&quot; deps is a list containing four dependencies: Font Awesome handles icons Bootstrap is the main HTML/CSS/JS template. Importantly, please note the version 3.3.7, whereas the current is 4.5.2 AdminLTE is the dependency containing HTML/CSS/JS related to the admin template. It is closely linked to Bootstrap 3. shinydashboard, the CSS and javascript necessary for our dashboard to work properly. In practice, integrating custom HTML templates to shiny does not usually work out of the box for many reasons and some modifications are necessary. Below, we attach the dependencies to the box with tagList, as shown above. Notice that our custom box does not contain all parameters from shinydashboard, which is actually ok at this time. my_box &lt;- function(title, status) { tagList(box(title = title, status = status), deps) } ui &lt;- fluidPage( titlePanel(&quot;Shiny with a box&quot;), my_box(title = &quot;My box&quot;, status = &quot;danger&quot;), ) server &lt;- function(input, output) {} shinyApp(ui, server) You now have limitless possibilities! Interestingly, this same approach is the basis of shinyWidgets for the useBs4Dash function and other related tools. 5.4 Suppress dependencies In rare cases, you may need to remove an existing conflicting dependency. The suppressDependencies function allows users to perform this. For instance, shiny.semantic built on top of semantic ui is not compatible with Bootstrap. Below, we remove the AdminLTE dependency from a shinydashboard page and nothing is displayed (as expected): shinyApp( ui = dashboardPage( dashboardHeader(), dashboardSidebar(), dashboardBody(suppressDependencies(&quot;AdminLTE&quot;)), title = &quot;Dashboard example&quot; ), server = function(input, output) { } ) 5.5 Insert Custom script in the head With {shinydashboardPlus}, users can fine tune their dashboard behavior with a simple option parameter passed to dashboardPagePlus. The sidebarExpandOnHover capability that consists in expanding the sidebar when hovering on it is part of those options, yet not exposed by {shinydashboard}. Under the hood, all those options are gathered in a (nested) list, then converted into JSON to eventually generate a JavaScript configuration file. Until now, we only saw ways to include static scripts/stylesheets. How do we include any arbitrary script (defined on the fly by the user when the app starts) in an dependency? htmlDependency has a head parameter allowing to pass any lines of HTML to insert into the document head. We can easily imagine passing a string containing a script. Below, we first construct the options list. Then, we create the dependency: notice since src is mandatory, we have to give it a value but we will not use script nor stylesheet arguments. options &lt;- list( sidebarExpandOnHover = TRUE, boxWidgetSelectors = list( remove = &#39;[data-widget=&quot;remove&quot;]&#39; ) ) config_script &lt;- function() { htmlDependency( &quot;options&quot;, as.character(utils::packageVersion(&quot;shinydashboardPlus&quot;)), src = c(file = system.file(&quot;shinydashboardPlus-0.6.0&quot;, package = &quot;shinydashboardPlus&quot;)), head = if (!is.null(options)) { paste0( &quot;&lt;script&gt;var AdminLTEOptions = &quot;, jsonlite::toJSON( options, auto_unbox = TRUE, pretty = TRUE ), &quot;;&lt;/script&gt;&quot; ) } ) } # show the script print(HTML(config_script()$head)) ## &lt;script&gt;var AdminLTEOptions = { ## &quot;sidebarExpandOnHover&quot;: true, ## &quot;boxWidgetSelectors&quot;: { ## &quot;remove&quot;: &quot;[data-widget=\\&quot;remove\\&quot;]&quot; ## } ## };&lt;/script&gt; I invite the reader to run the example below involving {shinydashboardPlus}, open the HTML inspector and look at the head. shinyApp( ui = dashboardPagePlus( collapse_sidebar = TRUE, options = options, header = dashboardHeaderPlus( enable_rightsidebar = TRUE, rightSidebarIcon = &quot;gears&quot; ), sidebar = dashboardSidebar(), body = dashboardBody(), rightsidebar = rightSidebar(), title = &quot;DashboardPage&quot; ), server = function(input, output) { } ) According the the AdminLTE documentation, global options must be passed before loading the app.min.js script. Creating this “dummy” dependency allowed us to isolate the script to insert it before the app.min.js script (contained in another dependency), as shown on Figure 5.1. FIGURE 5.1: Insert arbitrary script in the head "],
["htmltools-other-tools.html", "Chapter 6 Other tools 6.1 CSS", " Chapter 6 Other tools 6.1 CSS Sometimes, it is temptating to write inline CSS for a tag in the style attribute, for instance: title &lt;- h4( &quot;A title&quot;, style = &quot;color: cyan; text-align: center; margin-top: 100px;&quot; ) shinyApp(ui = title, server = function(input, output) {}) As the number of CSS properties grows, the code may become hard to read. The {cascadess} package developed by Nathan Teetor provides a more readable syntax, which works well with %&gt;%. ui &lt;- list( cascadess(), h4( &quot;A title&quot;, .style %&gt;% text(color = &quot;cyan&quot;, align = &quot;center&quot;) %&gt;% margin(top = 5) ) ) shinyApp(ui, server = function(input, output) {}) {cascadess} is a pleasing way to learn CSS through R. For instance, the CSS text formating includes properties like text-color, text-align, …The text function has the same parameters, namely color, align, as shown in the above example. Notice that we included the cascadess function, which is nothing more than an htmldependency object necessary to apply styles on elements. cascadess() ## List of 10 ## $ name : chr &quot;cascadess&quot; ## $ version : chr &quot;0.1.0&quot; ## $ src :List of 2 ## ..$ file: chr &quot;/Library/Frameworks/R.framework/Versions/3.6/Resources/library/cascadess/www/cascadess&quot; ## ..$ href: chr &quot;cascadess/cascadess&quot; ## $ meta : NULL ## $ script : NULL ## $ stylesheet: chr &quot;cascadess.min.css&quot; ## $ head : NULL ## $ attachment: NULL ## $ package : NULL ## $ all_files : logi TRUE ## - attr(*, &quot;class&quot;)= chr &quot;html_dependency&quot; Try to run the previous example without this element. Nothing will be properly displayed! "],
["survival-kit-javascript.html", "Chapter 7 JavaScript for Shiny 7.1 Shiny JavaScript sources 7.2 Introduction to JavaScript 7.3 Setup 7.4 Programming with JS: basis 7.5 jQuery 7.6 Shiny, JavaScript and the HTML inspector 7.7 Exercises", " Chapter 7 JavaScript for Shiny To understand how Shiny works from inside, especially understand how inputs are handled, we’ll need to dive into its core which contains a substantial amount of JavaScript (JS) files. 7.1 Shiny JavaScript sources Let’s have a look at the Shiny github project. As a R package, it is composed of folders like R, man, tests and other elements. The inst folder contains resources for external dependencies like Bootstrap 3, jQuery, datatables, fontawesome, … mentioned in Chapter 3 sorted in the www/shared sub-folder as well as the whole CSS and JS Shiny codes. Notice the presence of minified files like shiny.min.js and non minified elements such as shiny.css. Overall, the minification process reduces the loading time of a web page by removing comments, extra spaces, thereby decreasing the file size. For instance shiny.js has 6628 lines of code, while shiny.min.js has only 4. Notice the srcjs/ folder shown in Figure 7.1. It actually contains all pieces to reconstruct the whole shiny.js file. FIGURE 7.1: Shiny JavaScript sources The _start.js and _end.js are used by the Gruntfile.js, that is a grunt-based tool to run different tasks such as concatenate multiple JavaScript files, lint the code, minify it … See here for a summary. grunt.registerTask(&#39;default&#39;, [ &#39;concat&#39;, &#39;string-replace&#39;, &#39;validateStringReplace&#39;, &#39;eslint&#39;, &#39;configureBabel&#39;, &#39;babel&#39;, &#39;uglify&#39; ]); Since in Chapter (shiny-input-system) we’ll use some of those script, a little understanding of the basic underlying JavaScript concepts is necessary. 7.2 Introduction to JavaScript JavaScript was created in 1995 by Brendan Eich and is also known as ECMAScript (ES). Interestingly, you might have heard about ActionScript, which is no more than an implementation of ES by Adobe Systems. Nowadays, JavaScript is the centerpiece of web development across all websites. Here is a quick example. If you have a personal blog, you probably know Hugo or Jekyll. These tools allow one to rapidly develop a professional looking (or at least not too ugly) blog in just a few minutes. This allows bloggers to focus on the content, which is really the point! Now, if you open the HTML inspector introduced in Chapter 2.2, click on the elements tab, which may open by default, and uncollapse the &lt;head&gt; tag, you see that a lot of scripts are included, as shown in Figure 7.2. Similarly for the &lt;body&gt; tag. FIGURE 7.2: A website is full of JavaScript There are 2 ways to include scripts: Use the &lt;script&gt; tag with the JS code inside Add the onclick attribute to a button to trigger JS as soon as it is clicked (This is similar to event listeners, see below) Import an external file containing the JS code and only &lt;script type=&quot;text/javascript&quot;&gt; // JS code here &lt;/script&gt; &lt;!-- We use the src attribute to link the external file --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;file.js&quot;&gt; Whether to choose the first, second or third method depends on the content of your script. If we consider the JS library jQuery, it unfortunately contains so much code making it a challenge to understand. This often makes users avoid the first method. 7.3 Setup Like R or Python, JavaScript (JS) is an interpreted language, executed client-side, in other words in the browser. This also means that JS code may not be run without a suitable tool. 7.3.1 Node Node contains an interpreter for JS as well as a dependencies manager, npm (Node Package Manager). To install Node on your computer, browse to the website and follow the installation instructions. Afterwards, open a terminal and check if $ which node $ node --version returns something. If not, Node may not be properly installed. 7.3.2 Choose a good IDE Personally, I really like VSCode for coding with JS, as it contains a Node interpreter allowing you to seamlessly execute any JS code. As a side note, I encourage you to try the dracula color theme, which is my favorite! Many also chose the Rstudio IDE, provided that you have Node installed. Below, we will see how to run a JS code in both IDE’s. In section 7.6, we will show how to manipulate JS code directly in the web browser, through the HTML inspector. This is the method we will mostly use in the remaining of the book since we will also work with HTML and CSS at the same time. 7.3.3 First Script Let’s write our first script: console.log(&quot;Hello World&quot;); You notice that all instruction end by ;. You can run this script either in Rstudio IDE or VSCode. FIGURE 7.3: Run JS in VSCode In VSCode, clicking on the run arrow (top center) of Figure 7.3, triggers the node hello.js command, which tells Node to run the script. We see the result in the right panel (code=0 means the execution is fine and we even have the compute time). To run this script in the RStudio IDE, one needs to click on the terminal tab (you could also open a basic terminal) and type node hello.js (or node mycustompath/hello.js if you are not in the folder containing the script). You should see the Hello World message in the console (see Figure 7.4). FIGURE 7.4: Run JS in a terminal 7.4 Programming with JS: basis We are now all set to introduce the basis of JS. As many languages, JS is made of variables and instructions. All instructions end by the ; symbol. 7.4.1 JS types JS defines several types: Number: does not distinguish between integers and others (in R for instance, numeric contains integers and double) String: characters (‘blabla’) Boolean: true/false To check the type of an element, we may use the typeof operator. typeof 1; // number typeof &#39;pouic&#39;; // string In JS, typeof is not a function like in R!!! Therefore don’t write typeof('string');. 7.4.2 Variables Variables are key elements in programmation. They allow to store intermediate results and do other manipulations. In JS, a variable is defined by: a type a name a value Valid variable names: don’t use an existing name like typeof don’t start with a number (123soleil) don’t include any space (total price) Besides, code style is a critical element in programming, increasing readability, and general consistence. There are several styles, the main ones being snake_case and camelCase. I personally use the camelCase syntax to write variables in JS. To set a variable we use let (there exists var but this is not the latest JS norm (ESMAScript 6 or ES6). You will see later that we still use var in the shiny core and many other R packages). There are two ways to create variables in JavaScript. 7.4.2.1 Const In JavaScript, a variable may be created with const: const n = 1; n = 2; // error const n = 3; // error const a; a = 1; // errors As shown above, such variables: Cannot be modified Cannot share the same name Must be assigned a value 7.4.2.2 let Another way to define a variable: let myVariable = &#39;welcome&#39;; myVariable = 1; console.log(myVariable); Then we may use all mathematical operators to manipulate our variables. let myNumber = 1; // affectation myNumber--; // decrement console.log(myNumber); // print 0 List of numerical operators in JS: + - * / % (modulo) ++ (incrementation) – (decrementation) To concatenate two strings, we use the+ symbol. You may also know var to declare variables. What is the difference with let? It is mainly a scope reason: var i = 1; { var i = 2; // this will modify i globally, not locally } console.log(`i is ${i}`); // i is 2. let j = 1; { let j = 2; // j is only declared locally and not globally! } console.log(`j is ${j}`); // j is 1 7.4.3 Conditions Below are the operators to check conditions. == (A equal B) != (A not equal to B) &gt; (&gt;=) &lt; (&lt;=) AND (A AND B) OR (A OR B) To test conditions there exists several ways: if (condition) { console.log('Test passed'); } if (condition) { instruction A} else { instruction B } This is very common to other languages (and R for instance). Whenever a lot of possible conditions need to be evaluated, it is better to choose the switch. switch (variable) { case val1: // instruction 1 break; // don&#39;t forget the break! case val2: // instruction 2 break; default: // when none of val1 and val2 are satisfied } 7.4.4 Objects JavaScript is an object oriented programming language (like Python). An object is defined by: a type some properties some methods (to manipulate properties) Let’s define our first object below: const me = { name : &#39;Divad&#39;, age : 29, music : &#39;&#39;, printName: function() { console.log(`I am ${this.name}`); } } me.geek = true; // works (see const variables above) console.log(JSON.stringify(me)); // print a human readable object. console.log(me.name); console.log(me.age); console.log(me.music); // don&#39;t repeat yourself!!! for (let key in me) { // here is it ok to use `in` console.log(`me[${key}] is ${me[key]}`); } me.printName(); me = { name: &#39;Paul&#39;, age: 40 } // error (see const variables above) Some comments on the above code: to access an object propertie, we use object.propertie to print a human readable version of the object JSON.stringify will do the job we introduced string interpolation with ${*}. * may be any valid expression. methods are accessed like properties (we may also pass parameters). We use this to refer to the object itself. Take note, we will see it a lot! In JavaScript, we can find already predefined objects to interact with arrays, dates. 7.4.4.1 Arrays An array is a structure allowing to store informations for instance const table = [1, &#39;plop&#39;]; table.push(&#39;hello&#39;); table = [2]; // error (as explain in above in the variable part) console.log(table); Array may be nested const nested = [1, [&#39;a&#39;, [1, 2, 3]], &#39;plop&#39;]; console.log(nested); In arrays, elements may be accessed by their index, but as mentionned before, the first index is 0 (not 1 like in R). A convenient way to print all arrays’s elements is to use an iteration: const nested = [1, [&#39;a&#39;, [1, 2, 3]], &#39;plop&#39;]; for (let i of nested) { console.log(i); } // or with the classic approach for (let i = 0; i &lt; nested.length; i++) { console.log(nested[i]); } Note that the length method returns the size of an array and is very convenient in for loops. Below is a table referencing the principal methods for arrays (we will use some of them later) Method/Property Description length Return the number of elements in an array Join(string separator) Transform an array in a string concat(array1, array2) Assemble 2 arrays pop() Remove the last element of an array shift() Remove the first element of an array unshift(el1, el2, …) Insert elements at the beginning of an array push(el1, el2, …) Add extra elements at the end of an array sort() Sort array elements by increasing value of alphabetical order reverse() Symetric of sort() Quite honestly, we mainly use push and length in the next chapters. 7.4.4.2 Strings Below are the main methods related to the String object (character in R) Method/Property/Operator Description + (operator) String concatenation length String length indexOf() Gives the position of the character following the input string toLowerCase() Put the string in small letters toUpperCase() Put the string in capital letters 7.4.4.3 Math Below we mention some useful methods to handle mathematical objects Method Description parseInt() Convert a string to integer parseFloat() Conversion to floating number All classic functions like sqrt, trigonometric functions are of course available. We call them with the Math.* prefix. 7.4.5 Iterations Iterations allow to repeat an instruction or a set of instructions multiple times. Let’s assume we have an array containing 100000 random numbers. How would you do to automatically print them? This a what we are going to see below! 7.4.5.1 For loops The for loop has multiple uses. Below is a classic case where we start by defining the index (variable). We then set an upper bound (the array length) and we finish by incrementing the index value. The code between curly braces is then executed. const table = [...Array(100).keys()]; // create an empty array of length 100 (so from 0 to 99, not from 1 to 100 like in R!!!) for (let i = 0; i &lt; table.length; i++) { console.log(table[i]); } The way we created the array is a bit special and deserves some explanations: Array is a method to define a new array. We call it this way Array(arrayLength) since we don’t want to write 100 values 1 by 1. But if you try console.log(Array(10)); you will get [ &lt;10 empty items&gt; ], meaning that 10 slots are available but nothing is inside yet. keys defines keys for each table index. As a reminder, since Array(10) is an object (check with console.log(typeof Array(10));) we may use Array(10).keys(). This creates an Array Iterator ... is a spread syntax, and is called with an iterable object (see above) NOTE: Contrary to R, JavaScript index starts from 0 (not from 1)! This is good to keep in mind when we will mix both R and JS. Let’s have a look at the forEach method for arrays (introduced in ES5): const letters = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]; letters.forEach((letter) =&gt; { console.log(letter); }); Below is another way to create a for loop (introduced in ES6): const samples = [&#39;blabla&#39;, 1, null]; // this is an array! for (let sample of samples) { console.log(sample); } What loop for loop should we use? The answer is: it depends on the situation! Actually, there even exists other ways (replace of by in and you get the indexes of the array, like with the first code, but this is really not recommended). 7.4.5.2 Other iterations: while While loops are another way to iterate, as long as the condition defined is TRUE. The incrementation step is done at the end of the instruction. const h = 3; i = 0; while (i &lt;= h) { console.log(i); i++; // we need to increment to avoid infinite loop } 7.4.6 Functions Functions are useful to wrap a succession of instructions to accomplish a given task. Defining functions allows programmers to save time (less copy and paste, less search and replace), make less errors and easily share code. In modern JavaScript (ES6), functions are defined as follows: const a = 1; const fun = (parm1, parm2) =&gt; { console.log(a); let p = 3; return Math.max(parm1, parm2); // I use the Math object that contains the max method } let res = fun(1, 2); console.log(res); // prints a and 2. a global console.log(p); // fails because p was defined inside the function This above functions computes the maximum of 2 provided numbers. Some comments about scoping rules: variables defined inside the function are available for the function, but are not available outside the function definition. It should be noted that functions may use global variables defined outside of it. 7.4.6.1 Export functions: about modules What happens if you wrote 100 functions that you want to reuse in different scripts? To prevent copying and pasting, we will now introduce the concept of modules. Let’s save the below function in a script utils.js: const findMax = (parm1, parm2) =&gt; { return Math.max(parm1, parm2); // I use the Math object that contains the max method } module.exports = { findMax = findMax } Let’s create a test.js script in the same folder that uses the findMax function. To do this, we need to import the corresponding module: const {findMax} = require(&#39;./utils.js&#39;); findMax(1, 2); // prints 2 In the next chapters, we will see that some of the underlying JS code to build custom shiny inputs share the same utils functions. Therefore, introducing modules is necessary. 7.4.7 Event listeners When you explore a web application, clicking on a button usually triggers something like a computation, a modal or an alert. How does this work? In JavaScript, interactivity plays a critical role. Indeed, you want the web application to react to user inputs like mouse clicks, keyboard events. Below we introduce DOM events. Let’s consider a basic HTML button. &lt;button id=&quot;mybutton&quot;&gt;Go!&lt;/button&gt; On the JavaScript side, we first capture the button element using its id selector (getElementById). const btn = document.getElementById(&#39;mybutton&#39;); We then apply the addEventListener method. In short, an event listener is a program that triggers when a given event occurs (we can add multiple event listeners per HTML element). It takes 2 main parameters: the event: click, change, mouseover, … the function to call btn.addEventListener(&#39;click&#39;, function() { alert(&#39;Thanks!&#39;); }); We could compare the JavaScript events to Shiny observeEvent in which we are listenning to a specific user input. 7.5 jQuery 7.5.1 Introduction jQuery is a famous JavaScript library providing a user friendly interface to manipulate the DOM and is present in almost all actual websites. It is slightly easier (understand more convenient to use) than vanilla JS, even though web developers tend to avoid it to go back to vanilla JS (Bootstrap 5, the next iteration of Bootstrap will not rely on jQuery anymore). To use jQuery in a webpage, we must include its code either by dowloading the code and putting the minified JS file in our HTML or setting a link to a CDN. &lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Including jQuery&lt;/title&gt; &lt;!-- How to include jQuery --&gt; &lt;script src=&quot;https://code.jquery.com/jquery-3.5.0.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello World&lt;/p&gt; &lt;script&gt; $(&#39;p&#39;).css(&#39;color&#39;, &#39;red&#39;); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 7.5.2 Syntax Below is a minimal jQuery code representing its philosophy (“write less, do more.”): $(selector).action(); The selector slot stands for any jQuery selector like class, id, element, [attribute], :input (will select all input elements) and many more. As a reminder, let’s consider the following example: &lt;p class=&quot;text&quot;&gt;Hello World&lt;/p&gt; To select and interact with this element, we use JavaScript and jQuery: let inner = document.getElementsByClassName(&#39;text&#39;).innerHTML; // vanilla JS let inner = $(&#39;.text&#39;).html(); // jQuery This is of course possible to chain selectors &lt;ul class=&quot;list&quot;&gt; &lt;li class=&quot;item&quot;&gt;1&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;2&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;3&lt;/li&gt; &lt;li class=&quot;item&quot; id=&quot;precious-item&quot;&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;ul class=&quot;list&quot; id=&quot;list2&quot;&gt; &lt;li class=&quot;item&quot;&gt;1&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;2&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;3&lt;/li&gt; &lt;li class=&quot;item&quot;&gt;4&lt;/li&gt; &lt;/ul&gt; let items = $(&#39;.list .item&#39;); // will return an array containing 8 li tags let otherItems = $(&#39;#list2 .item&#39;); // will select only li tags from the second ul element let lists = $(&#39;ul&#39;); // will return an array with 2 ul elements let firstItem = $(&#39;#list2:first-child&#39;); // will return the first li element of the second ul. jQuery is obviously simpler than pure JavaScript. 7.5.3 Useful functions There exist filtering functions dedicated to simplify item selection. We gathered the one mostly used in Shiny below. 7.5.3.1 Travel in the DOM Method Description children() Get the children of each element passed in the selector (important: only travels a single level down the DOM tree) first() Given an list of elements, select the first item last() Given an list of elements, select the last item find() Look for a descendant of the selected element(s) that could be multiple levels down in the DOM closest() Returns the first ancestor matching the condition (travels up in the DOM) filter() Fine tune element selection by applying a filter. Only return element for which the condition is true siblings() Get all siblings of the selected element(s) next() Get the immediately following sibling prev() Get the immediately preceding sibling not() Given an existing set of selected elements, remove element(s) that match the given condition 7.5.3.2 Manipulate tags Below is a list of the main jQuery methods to manipulate tags (adding class, css property…) Method Description addClass() Add class or multiple classes to the set of matched elements hasClass() Check if the matched element(s) have a given class removeClass() Remove class or multiple classes to the set of matched elements attr() Get or set the value of a specific attribute after() Insert content after before () Insert content before css() Get or set a css property remove() Remove element(s) from the DOM val() Get the current value of the matched element(s) TO DO: add more methods 7.5.4 Chaining jQuery methods A lot of jQuery methods may be chained, that is like pipe operations in R. &lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;li&gt;Item 4&lt;/li&gt; &lt;li&gt;Item 5&lt;/li&gt; &lt;/ul&gt; We end the chain by ; and each step is indent by 2 spaces in the right direction. $(&#39;ul&#39;) .first() .css(&#39;color&#39;, &#39;green&#39;) // add some style with css .attr(&#39;id&#39;, &#39;myAwesomeItem&#39;) // add an id attribute .addClass(&#39;amazing-ul&#39;); 7.5.5 Iterations Like in vanilla JavaScript, it is possible to do iterations in jQuery. Let’s consider the following HTML elements. &lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;/ul&gt; We apply the each method to change the style of each matched element step by step. $(&#39;li&#39;).each(function() { $(this).css(&#39;visibility&#39;, &#39;hidden&#39;); // will hide all li items }); Notice that the following code $('li').css('visibility', 'hidden'); will do exactly the same! This is explained by the implicit iteration process handled by most of jQuery methods. The map methods has a different purpose. It creates a new object based on the provided one. const items = [0, 1, 2, 3, 4, 5]; const threshold = 3; let filteredItems = $.map(items, function(i) { // removes all items &gt; threshold if (i &gt; threshold) return null; return i; }); 7.5.6 Good practice It is recommended to wrap any jQuery code as follows: $(document).ready(function(){ // your code }); // or a shortcut $(function() { // your code }); Indeed, do you guess what would happen if you try to modify an element that does not even exist? The code above will make sure that the document is ready before starting any jQuery manipulation. 7.5.7 Events In jQuery there exists a significant number methods related to events. Below are the most popular: $(element).click(); // click event $(element).change(); // trigger change on an element $(element).on(&#39;click&#39;, function() { // whatever }); // attach an event handler function. Here we add click for the example $(element).one(&#39;click&#39;, function() { // whatever }); // the difference with on is that one will trigger only once $(element).resize(); // useful to trigger plot resize in Shiny so that they correctly fit their container $(element).trigger(&#39;change&#39;) // similar to $(element).change(); You will find it in the Shiny core. The .on event is frequently used in Shiny since it allows to pass custom events which are not part of the JS prefined events. For instance shinydashboard relies on a specific HTML/JavaScript/CSS template including a homemade API for handling the dashboard events. Don’t worry if this section is not clear at the moment. We will see practical examples in the following chapters. 7.5.8 Extending objects A last feature we need to mention about jQuery is the ability to extend objects with additional properties and/or method. // jQuery way $(function() { let object1 = { apple: 0 }; $.extend(object1, { print: function() { console.log(this); } }); object1.print(); }); With vanilla JS we would use Object.defineProperty: // pure JavaScript Object.defineProperty(object1, &#39;print&#39;, { value: function() { console.log(this); }, writable: false }); 7.6 Shiny, JavaScript and the HTML inspector 7.6.1 The console panel The console panel is located at the bottom of the inspector and is intended for debugging purpose. While developing JS code, we often put some console.log(var) calls to track the content of a given variable and check that our code is doing what it is supposed to do. This console is also called a Real-eval-print loop (REPL) suitable to experiment and practice your new JS/jQuery skills. 7.6.1.1 A real REPL As a warm up, run the shiny app below and open the Chrome DevTools. Notice the 2 Console tabs (next to Elements and at the bottom), as depicted in Figure 7.5. I prefer using the bottom one to still see the Elements tab and preview DOM modifications in real time. ui &lt;- fluidPage() server &lt;- function(input, output, session) {} shinyApp(ui, server) FIGURE 7.5: Console panel in the DevTools Interestingly, you may access any element contained in the window. Copy and paste $(\"body\").addClass(\"plop\"); in the prompt. Notice what happens in the Elements tab. 7.6.1.2 Track errors and warnings As discussed earlier in the book, a lot of issues on Stack Overflow or in the RStudio community could be more easily solved by quickly inspecting the console. 7.6.2 Debug Shiny/JS code with the inspector To debug Shiny apps from the inspector, you need to put all your scripts in a folder accessible by the app like the www/ folder or by using shiny::addResourcePath. Moreover, if you have minified files, there must be source maps, which will allow to reconstruct the original scripts before the minification process. For instance, Shiny has the shiny.min.js.map. In practice, most R packages bundling HTML templates do not ship these files since they could be quite large (see package size restriction for CRAN). The framework7 HTML template, on top of which is built shinyMobile has source maps but the size can reach 1MB which is obviously too big to include in the R package. In the following, let’s consider a very simple shiny app deployed on shinyapps.io, where a notification is displayed with JavaScript as soon as a user clicks an action button. I also made some typos in my code and the goal is to find and fix them. Browse to the app Open the Chrome DevTools Click on the action button (I am pretty sure you clicked before step 2 ;)) As expected and shown Figure 7.6, the console displays an error message: Uncaught TypeError: Cannot read property 'show' of undefined. Sounds good isn’t it? FIGURE 7.6: Error in the console panel Expand the error message to show the stack trace. We see that the error occurred during an onclick event calling the sendNotif function. Interestingly, we can open this file by clicking on the provided link (notif.js:2). You should get a layout similar to Figure 7.7, depending on your screen width. FIGURE 7.7: Inspect the source causing the error Let’s briefly describe Figure 7.7. On the left side, you can navigate through all files accessible by the web server, that is shiny internal resources, shiny external dependencies (like Bootstrap 3) as well as your own scripts. If the app is deployed on shinyapps.io, all scripts are located in a folder starting by _w_, which corresponds to the shinyapps.io workerId (this is a detail and not important to understand. See more here). The central part contains any opened script like a classic IDE. The right side displays debugging tools which you may trigger by clicking on the corresponding accordion. The scope shows all variables/object values at a break point, watch allows to track specific elements and Event listener Breakpoints allows to stop at given listener type. We could create a new “watcher” by entering typeof message and clicking the add icon to check the message type within the sendNotif function. Watched expressions are saved when you close the browser. Put a break point line 2 by clicking on the left side of the center panel and click again on the action button to trigger the break point. I also additionally set 2 Watch Expressions (for message and duration) which type is string and number, respectively, as depicted on Figure 7.8. According to the results, nothing seems wrong for the function arguments. FIGURE 7.8: Inspection of the scope at the breakpoint The error message Uncaught TypeError: Cannot read property 'show' of undefined actually means that notification does not exist. Try yourself by typing Shiny.notification in the console. You’ll get undefined. Instead, the console suggests Shiny.notifications. Let’s replace the wrong code in the notif.js script and then save it. Click on the “Resume script execution” blue button (top left of the right panel). Notice that a notification is displayed and no more error is thrown. Congrats! You’ve just debugged your first shiny app from the web inspector. In practice, your code will probably be much more complex than this example but the workflow remains the same. 7.7 Exercises Because the JavaScript console is a REPL, all JavaScript exercises may be done inside, except exercise 3 which also involves HTML. 7.7.1 Exercise 1: define variables Play with the example below let myNumber = 1; // affectation myNumber--; // decrement console.log(myNumber); // print 0 7.7.2 Exercise 2: define objects Below is an object skeleton. const me = { name : , age : , music : , printName: function() { console.log(`I am ${}`); } } Fill it with some random values. Access the name property. Create the printAge method, which returns the age. Hint: this refers to the object itself. For instance this.name gives the name property. 7.7.3 Exercise 3: jQuery JSFiddle allows to insert HTML, CSS and JavaScript to test code, share and more. It also does not require you to have any specific configuration on your machine so that you focus on testing! Go to JSFiddle Insert the following HTML code chunk in the HTML sub-window. &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;!-- head content here --&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;li&gt;Item 3&lt;/li&gt; &lt;li&gt;Item 4&lt;/li&gt; &lt;li&gt;Item 5&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; This is a very basic HTML skeleton In the JavaScript windows, select jQuery 3.4.1 in the dropdown menu (why 3.4.1? The latest Shiny release relies on that version. It is therefore best practice to ensure dependencies are similar, at least the major version). Since it is best practice to run jQuery code only when the document is ready (avoiding to target non existing elements), we wrap our JS code in the following: $(function() { // your code }); // or a more explicit syntax $(document).ready(function() { // code }); Create an event listener to change the third item color as soon as one click on it. Hint 1: To select the a specific item you may use $(selector:eq(i)) where i is the index of the element. Keep in mind that JavaScript starts from 0 and not 1 like R! Hint 2: as a reminder, to create an event listener in jQuery, we use the following pattern. $(&quot;selector&quot;).on(&quot;event_name&quot;, function(e) { // your logic }); 7.7.4 Exercise 4: a pure JS action button Below is another example of a button element with an attached event listener. Clicking on the button will increment its value by 1. Fill in the blanks! &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;!-- head content here --&gt; &lt;/head&gt; &lt;body&gt; &lt;button&gt;click&lt;/button&gt; &lt;/body&gt; &lt;/html&gt; $(function() { // recover the button inner html const btnText = ...; // event listener for button element $(...).click(function() { var val = ...; // (1) increment button // (2) add the button value to the inner text ... // show alert given condition if (val &gt; 3) { // do whatever you want ... } }); }); "],
["shiny-intro.html", "Chapter 8 Introduction 8.1 Websocket: R/JS bidirectional communication 8.2 The Shiny session object 8.3 The Shiny JavaScript object", " Chapter 8 Introduction In this chapter, we will answer to the following questions: How is R/JavaScript communication achieved? How does Shiny deal with inputs? In the last part of this book, we will be designing custom inputs and knowing how to debug them is priceless. 8.1 Websocket: R/JS bidirectional communication How does R (server) and JavaScript (client) communicate? This is a built-in Shiny feature highlighted here, which leverages the httpuv and websocket packages. Before going further let’s define what is a websocket! It is an advanced technology allowing bidirectional communication between a client and a server. For instance, a chat system may be built on top of a websocket. In the following, we will show how to inspect the websocket in a web browser. Let’s run the following app (see 8.1, left panel) library(shiny) shinyApp( ui = fluidPage( selectInput(&quot;variable&quot;, &quot;Variable:&quot;, c(&quot;Cylinders&quot; = &quot;cyl&quot;, &quot;Transmission&quot; = &quot;am&quot;, &quot;Gears&quot; = &quot;gear&quot;)), tableOutput(&quot;data&quot;) ), server = function(input, output) { output$data &lt;- renderTable({ mtcars[, c(&quot;mpg&quot;, input$variable), drop = FALSE] }, rownames = TRUE) } ) After opening the HTML inspector, we select the network tab and search for websocket in the list. By choosing the message tab, you may inspect what R and JavaScript say to each others. On the JavaScript side, the websocket is created in the shinyapp.js file. The first element received from R is the first message in the list shown in Figure 8.1. It is a JSON object containing the method used as well as passed data. In the meantime, you may change the select input value. socket.send(JSON.stringify({ method: &#39;init&#39;, data: self.$initialInput })); The second message received from R is after updating the select input. this.sendInput = function(values) { var msg = JSON.stringify({ method: &#39;update&#39;, data: values }); // other things }; Although complex, it is extremely useful to check whether the input / output communication are working properly. If not, we would see the error field identifying the issue. Finally, Shiny.shinyapp.$socket.readyState returns the state of the socket connection. It should be 1 if your app is running. In some instances when the socket is closed, an error would be raised. Note that the R option options(shiny.trace = TRUE) allows the websocket messages to be displayed directly in the R console. FIGURE 8.1: Shiny websocket We see below that we can even bypass the UI element and update the input value directly via the websocket using Shiny.shinyapp.$sendMsg with the update method. updateObsVal &lt;- function(value) { sprintf( &quot;Shiny.shinyapp.$sendMsg(JSON.stringify({ method: &#39;update&#39;, data: {obs: %s} }));&quot;, value ) } # below we shunt the slider input by sending message # directly through the websocket ui &lt;- fluidPage( tags$button( &quot;Update obs value&quot;, onclick = updateObsVal(4) ), sliderInput(&quot;obs&quot;, &quot;Number of observations:&quot;, min = 0, max = 1000, value = 500 ), plotOutput(&quot;distPlot&quot;) ) server &lt;- function(input, output, session) { output$distPlot &lt;- renderPlot({ hist(rnorm(input$obs)) }) } shinyApp(ui, server) 8.2 The Shiny session object We won’t be able to go anywhere without giving some reminders about the Shiny session object. Why do we say object? session is actually an instance of the ShinySession R6 class. The initialization takes one parameter, namely the websocket. As shown in the last section, the websocket allows bidirectional exchanges between R and JS. Understanding how R and JS communicate allows us to discuss the Shiny input system. sendCustomMessage sends messages from R to JS. It calls the private sendMessage method which itself calls write. The message is sent only when the session is opened, throught the websocket private$websocket$send(json). If the shiny.trace option is TRUE, a message showing the sent JSON is displayed, which is useful for debugging. sendInputMessage is used to update inputs from the server The below code is extracted from the shiny.R file. sendCustomMessage = function(type, message) { data &lt;- list() data[[type]] &lt;- message private$sendMessage(custom = data) } sendInputMessage = function(inputId, message) { data &lt;- list(id = inputId, message = message) # Add to input message queue private$inputMessageQueue[[length(private$inputMessageQueue) + 1]] &lt;- data # Needed so that Shiny knows to actually flush the input message queue self$requestFlush() } sendMessage = function(...) { # This function is a wrapper for $write msg &lt;- list(...) if (anyUnnamed(msg)) { stop(&quot;All arguments to sendMessage must be named.&quot;) } private$write(toJSON(msg)) } write = function(json) { if (self$closed){ return() } traceOption &lt;- getOption(&#39;shiny.trace&#39;, FALSE) if (isTRUE(traceOption) || traceOption == &quot;send&quot;) message(&#39;SEND &#39;, gsub(&#39;(?m)base64,[a-zA-Z0-9+/=]+&#39;,&#39;[base64 data]&#39;,json,perl=TRUE)) private$websocket$send(json) } # ... No worry if it is not clear at the moment. We will discuss those elements in the following sections. 8.3 The Shiny JavaScript object The Shiny object is exported at the top of the shiny.js file.3 In other words, this means that we may use this object and any of its properties within the HTML inspector console tab, in any JavaScript file or shiny app as below. ui &lt;- fluidPage( tags$script( &quot;$(function() { console.log(Shiny); }); &quot; ) ) server &lt;- function(input, output, session) {} shinyApp(ui, server) This object contains many properties and methods as shown in Figure 8.2. Some of particular interest, such as like Shiny.setInputValue, Shiny.addCustomMessageHandler, Shiny.shinyapps, Shiny.bindAll, … will be detailed later FIGURE 8.2: The Shiny JavaScript object Refer to Chapter 7 if you don’t remember how to export an object and make it available to all JS files.↩︎ "],
["shiny-input-system.html", "Chapter 9 Shiny’s input system 9.1 Initialization 9.2 Input bindings 9.3 Utilities to quickly define new inputs 9.4 Hidden gems about inputs", " Chapter 9 Shiny’s input system Shiny inputs are key elements of Shiny apps since they are a way for the end-user to interact with the app. You may know sliderInput, numericInput, checkboxInput but sometimes you may need fancier elements like knobInput from shinyWidgets, as depicted on Figure 9.1 or even more sophisticated inputs like the smartSelect of shinyMobile (Figure 9.1, right panel). Have you ever wondered what are the mechanisms behind inputs? Have you ever dreamt to develop your own? The goal of this section is to understand how Shiny inputs work. FIGURE 9.1: Custom shiny inputs. left: knobInput from shinyWidgets; right: smart select from shinyMobile 9.1 Initialization When we run our app, most of the time it works just fine! The question is, how are the inputs and outputs handled correctly to allow this to happen? Upon initialization, Shiny runs several JavaScript functions. Not surprisingly, there is one called init_shiny containing a substantial number of elements such as bindInputs and unbindInputs to bind/unbind inputs. Besides, they are accessible to the programmer (see a usecase here). To illustrate what they do, let’s run the app below. library(shiny) ui &lt;- fluidPage( sliderInput(&quot;obs&quot;, &quot;Number of observations:&quot;, min = 0, max = 1000, value = 500 ), plotOutput(&quot;distPlot&quot;) ) server &lt;- function(input, output, session) { output$distPlot &lt;- renderPlot({ hist(rnorm(input$obs)) }) } shinyApp(ui, server) We then open the HTML inspector and run Shiny.unbindAll(document) (document is the scope, that is where to search). Try to change the slider input. You will notice that nothing happens. Now let’s type Shiny.bindAll(document) and update the slider value. Moving the slider successfully update the plot. Magic isn’t it? This simply shows that when inputs are not bound, nothing happens so binding inputs is necessary. We consider another example with multiple inputs. ui &lt;- fluidPage( actionButton(&quot;unbind&quot;, &quot;Unbind inputs&quot;, onclick = &quot;Shiny.unbindAll();&quot;), actionButton(&quot;bind&quot;, &quot;Bind inputs&quot;, onclick = &quot;Shiny.bindAll();&quot;), lapply(1:3, function(i) { textInput(paste0(&quot;text_&quot;, i), paste(&quot;Text&quot;, i)) }), lapply(1:3, function(i) { uiOutput(paste0(&quot;val_&quot;, i)) }) ) server &lt;- function(input, output, session) { lapply(1:3, function(i) { output[[paste0(&quot;val_&quot;, i)]] &lt;- renderPrint(input[[paste0(&quot;text_&quot;, i)]]) }) } shinyApp(ui, server) Let’s see below what is an input binding and how it works. 9.2 Input bindings 9.2.1 Input structure An input element is given by the &lt;input&gt; tag as well as several attributes. &lt;input id = inputId type = &quot;text&quot; class = &quot;input-text&quot; value = value&gt; id guarantees the input uniqueness. We will see very soon that all instances of the same input share a unique input binding, therefore id is mandatory. type class is targeted by CSS and JavaScript value holds the input value 9.2.2 Binding Shiny inputs An input binding allows Shiny to identify each instance of a given input and what you may do with this input. For instance, a slider input must update whenever the range is dragged or when the left and right arrows of the keyboard are pressed. It relies on a class defined in the input_binding.js file. Let’s describe each method chronologically. For better convenience, the book side package contains step by step demonstrations which may be found here. Each example is called by the customTextInputExample, which takes the input binding step as only parameter. For instance customTextInputExample(1) will invoke the first step. 9.2.2.1 Find the input The first step, is critical which is to locate the input in the DOM. On the R side, we define an input, with a specific attribute that will serve as a receptor for the binding. For most of inputs, this may be handled by the type attribute. In other cases, this may be the class, like for the actionButton. On the JS side, we need a method that will identify this receptor. Moreover, two different types of inputs (for instance radioButton and selectInput) cannot have the same receptor for conflict reasons, whereas two instances of the same input type can (if your app contains 10 sliders, they all share the same input binding!). The receptor identifier is provided by the find method of the InputBinding class. This method must be applied on a scope, that is the document. find accepts any valid jQuery selector. Note the console.log only here for debugging purpose. find: function(scope) { console.log($(scope).find(&#39;.input-text&#39;)); return $(scope).find(&#39;.input-text&#39;); } Figure 9.2 summarizes this important step. FIGURE 9.2: How to find inputs? Below, we are going to create a new binding for the textInput, with only two methods mentioned in the previous section, that is find and getValue. For that, we need to create a customized text input, customTextInput to make it unique. We now add the input-text class and make our own input binding pointing to that specific class. customTextInput &lt;- function (inputId, label, value = &quot;&quot;, width = NULL, placeholder = NULL) { # this external wrapper ensure to control the input width div( class = &quot;form-group shiny-input-container&quot;, style = if (!is.null(width)) { paste0(&quot;width: &quot;, validateCssUnit(width), &quot;;&quot;) }, # input label shinyInputLabel(inputId, label), # input element + JS dependencies tagList( customTextInputDeps(), tags$input( id = inputId, type = &quot;text&quot;, class = &quot;form-control input-text&quot;, value = value, placeholder = placeholder ) ) ) } The last part of the code contains a tagList with two elements: The element input binding The input tag Below is an example of how we managed the dependency creation in our side package. Considering multiple inputs, we will add more script to the dependency by passing a vector to the script parameter. customTextInputDeps &lt;- function() { htmlDependency( name = &quot;customTextBindings&quot;, version = &quot;1.0.0&quot;, src = c(file = system.file(&quot;chapter5/input-bindings&quot;, package = &quot;OSUICode&quot;)), script = &quot;customTextInputBinding.js&quot; ) } In the shinyMobile package, we chose a more robust approach. All bindings are contained in a folder and compressed so that we generate only one minified file containing all collapsed bindings. Figure 9.3 shows the main elements of the textInput widget. In the above code, shinyInputLabel is a Shiny internal function that creates the numeric input label, or in other word the text displayed next to it. The core input element is wrapped by tags$input. No worry if the structure seems unclear, we will give more details about shiny tags in the Chapter 4. FIGURE 9.3: Shiny’s textInput elements We invite the reader to run the first example below and open the HTML inspector and look at the console.log result. customTextInputExample(1) Results are shown on Figure 9.4. If the corresponding input is found, you should see the corresponding tag element in the HTML inspector console. FIGURE 9.4: find method output 9.2.2.2 Initialize inputs Upon initialization, Shiny calls the initializeInputs function that takes all input bindings and call their initialize method before binding all inputs. Note that once an input has been initialized it has a _shiny_initialized tag to avoid initializing it twice. The initialize method is not always defined but some elements require to be explicitly initialized or activated. For instance the Framework7 API, on top of which shinyMobile is built, require to instantiate all elements. Below is an example for the toggle input: // what is expected let toggle = app.toggle.create({ el: &#39;.toggle&#39;, on: { change: function () { console.log(&#39;Toggle changed&#39;) } } }); el: '.toggle' means that we are looking at the element(s) having the toggle class. app.toggle.create is internal to the Framework7 API. The corresponding shinyMobile input binding starts as follows. var f7ToggleBinding = new Shiny.InputBinding(); $.extend(f7ToggleBinding, { initialize: function(el) { app.toggle.create({el: el}); }, // other methods }); Once initialized, we may use all specific methods provided by the API. Framework7 is clearly a gold mine, as its API provides many possible options for many inputs / widgets. 9.2.2.3 Get the value getValue(el) returns the input value. The way to obtain the value is different for almost all inputs. For instance, the textInput is pretty simple since the value is located in the value attribute. el refers to the element holding the id attribute and recognized by the find method. Figure 9.5 shows the result of a console.log($(el));. FIGURE 9.5: About el getValue: function(el) { console.log($(el)); return $(el).val(); } To get the value, we apply the jQuery method val on the $(el) element and return the result. customTextInputExample(2) This time, the input value is returned. Notice that when you try to change the text content, the output value does not update as we would normally expect. We are actually missing a couple of methods so that the binding is fully working. We will introduce them in the following sections! 9.2.2.4 Set and update setValue(el, value) is used to set the value of the current input. This method is necessary so that the input value may be updated. It has to be used in combination with receiveMessage(el, data), which is the JavaScript part of all the R updateInput functions. We usually call the setValue method inside. setValue: function(el, value) { $(el).val(value); } Let’s create a function to update our custom text input. Call it updateCustomTextInput. It requires at least 3 parameters: inputId tells which input to update. value is the new value. This will be taken by the setValue JS method in the input binding session is the Shiny session object mentioned earlier. We will use the sendInputMessage to send values from R to JavaScript. The receiveMessage method will apply setValue with the data received from R. updateCustomTextInput &lt;- function(inputId, value = NULL, session = getDefaultReactiveDomain()) { session$sendInputMessage(inputId, message = value) } We add setValue and receiveMessage to custom input binding. updateCustomTextInputExample(3) Figure 9.6 illustrates the main mechanisms. FIGURE 9.6: Events following a click on the update button. This figure demonstrates how R and JS communicate, through the websocket. If we have to pass multiple elements to update, we would have to change the updateCustomTextInput function such as: updateCustomTextInput &lt;- function(inputId, value = NULL, placeholder = NULL, session = getDefaultReactiveDomain()) { message &lt;- dropNulls( list( value = value, placeholder = placeholder ) ) session$sendInputMessage(inputId, message) } dropNulls is an internal function ensuring that the list does not contain NULL elements. We send a list from R, which is then serialized to a JSON object. In the receiveMessage method, properties like value may be accessed using the . notation: receiveMessage: function(el, data) { console.log(data); if (data.hasOwnProperty(&#39;value&#39;)) { this.setValue(el, data.value); } // other parameters to update... } So far so good! We managed to update the text input value. Yet, after clicking the button, the output value does not change. We are going to fix this missing step in the next section. 9.2.2.5 Subscribe subscribe(el, callback) listens to events defining Shiny to update the input value and make it available in the app. Some API like Bootstrap explicitly mention those events (like hide.bs.tab, shown.bs.tab, …). Going back to our custom text input, what event would make it change? After a key is release on the keyboard. We may listen to keyup After copying and pasting any text in the input field or dictating text. The input event may be helpful We may add those events to our binding using an event listener seen at the end of Chapter 7. $(el).on(&#39;keyup.customTextBinding input.customTextBinding&#39;, function(event) { callback(true); }); callback ensures that the new value is captured by Shiny. We will come back later on the callback parameter. updateCustomTextInputExample(4) Hooray! The output result is successfully changed when the input value is manually updated. However, nothing happens when we click on the update button. What did we miss? Looking back at the receiveMessage method, we changed the input value but how does Shiny knows that this step was successful? To check that no event is raised, we put a console.log(event); in the subscribe method. Any action like removing the text content or adding new text triggers event but clicking on the action button does not. Therefore, we must trigger an event and add it to the subscribe method. We may choose the change event, that triggers when an element is updated. $(el).on(&#39;change.customTextBinding&#39;, function(event) { callback(false); }); Let’s try again. updateCustomTextInputExample(5) Perfect? Not exactly. 9.2.2.6 Setting rate policies It would be better to only change the input value once the keyboard is completely released for some time (and not each time a key is released). This is what we call debouncing, which allows a delay before telling Shiny to read the new value, and is achieved using the getRatePolicy method. Additionally, we must also pass true to the callback in the subscribe method, in order to apply our specific rate policy (debounce, throttle). This is useful for instance when we don’t want to flood the server with useless update requests. For example when using a slider, we only want to send the value as soon as the range stops moving and not all intermediate values. Those elements are defined here. Run the app below and try to manually change the text input value by adding a couple of letters as fast as you can. What do you notice? We see the output value only updates when we release the keyboard. customTextInputExample(6) You may adjust the delay according to your needs, but we caution to not set the delay too long as this becomes problematic too. 9.2.2.7 Register an input binding At the end of the input binding definition, we register it for Shiny. let myBinding = new Shiny.inputBinding(); $.extend(myBinding, { // methods go here }); Shiny.inputBindings.register(myBinding, &#39;reference&#39;); Although the Shiny documentation mentions a Shiny.inputBindings.setPriority method to handle conflicting bindings, this case almost never happens. 9.2.3 Edit an input binding In some cases, we would like to access the input binding and change it’s default behavior, even though not always recommended, since it will affect all related inputs. As bindings are contained in a registry, namely Shiny.inputBindings, one may seamlessly access and modify them. This is a 5 steps process: Wait for the shiny:connected event Unbind all inputs with Shiny.unbindAll() Access the binding registry, Shiny.inputBindings Extend the binding and edit its content with $.extend(... {...}) Apply the new changes with Shiny.bindAll() $(function() { $(document).on(&#39;shiny:connected&#39;, function(event) { Shiny.unbindAll(); $.extend(Shiny .inputBindings .bindingNames[&#39;shiny.actionButtonInput&#39;] .binding, { // do whathever you want to edit existing methods }); Shiny.bindAll(); }); }); 9.2.4 Update a binding from the client The interest of receiveMessage and setValue is to be able to update the input from the server side, that is R, through the session$sendInputMessage. Yet, this task might be done directly on the client, thereby lowering the load on the server. We consider the following example: a shiny app contains 2 actions buttons, clicking on the first one increases the value of the second by 10. This won’t be possible with the classic approach since a button click only increases by 1. How do we proceed? We first set an event listener on the first button. We target the second button and get the input binding with $obj.data('shiny-input-binding') We recover the current value We call the setValue method of the input binding adding 10 to the current value Importantly, to let Shiny update the value on the R side, we must trigger an event that will be detected in the subscribe method of the action button input binding. The action button only has 1 event listener but other may be added. Don’t forget that triggering a click event would also increment the button value by 1! In the following we have to customize the subscribe method to work around $(function() { // each time we click on #test (a button) $(&#39;#button1&#39;).on(&#39;click&#39;, function() { var $obj = $(&#39;#button2&#39;); var inputBinding = $obj.data(&#39;shiny-input-binding&#39;); var val = $obj.data(&#39;val&#39;) || 0; inputBinding.setValue($obj, val + 10); $obj.trigger(&#39;event&#39;); }); }); If you click on the second button, the value increments only by 1 and the plot will be only visible after 10 clicks, while only 1 click is necessary on the first button. The reset button resets the second action button value to 0. It implements the feature discussed in the previous part, where we extend the button binding to add a reset method and edit the subscribe method to add a change event listener, simply telling shiny to get the new value. Contrary to click, change does not increment the button value. $.extend(Shiny.inputBindings.bindingNames[&#39;shiny.actionButtonInput&#39;].binding, { reset: function(el) { $(el).data(&#39;val&#39;, 0); }, subscribe: function(el, callback) { $(el).on(&#39;click.actionButtonInputBinding&#39;, function(e) { var $el = $(this); var val = $el.data(&#39;val&#39;) || 0; $el.data(&#39;val&#39;, val + 1); callback(); }); // this does not trigger any click and won&#39;t change the button value $(el).on(&#39;change.actionButtonInputBinding&#39;, function(e) { callback(); }); } }); Below is the working app. ui &lt;- fluidPage( tags$head( tags$script( &quot;$(function() { $(document).on(&#39;shiny:connected&#39;, function(event) { Shiny.unbindAll(); $.extend(Shiny .inputBindings .bindingNames[&#39;shiny.actionButtonInput&#39;] .binding, { reset: function(el) { $(el).data(&#39;val&#39;, 0); }, subscribe: function(el, callback) { $(el).on(&#39;click.actionButtonInputBinding&#39;, function(e) { var $el = $(this); var val = $el.data(&#39;val&#39;) || 0; $el.data(&#39;val&#39;, val + 1); callback(); }); $(el).on(&#39;change.actionButtonInputBinding&#39;, function(e) { debugger; callback(); }); } }); Shiny.bindAll(); }); $(&#39;#button1&#39;).on(&#39;click&#39;, function() { var $obj = $(&#39;#button2&#39;); var inputBinding = $obj.data(&#39;shiny-input-binding&#39;); var val = $obj.data(&#39;val&#39;) || 0; inputBinding.setValue($obj, val + 10); $obj.trigger(&#39;change&#39;); }); $(&#39;#reset&#39;).on(&#39;click&#39;, function() { var $obj = $(&#39;#button2&#39;); var inputBinding = $obj.data(&#39;shiny-input-binding&#39;); inputBinding.reset($obj); $obj.trigger(&#39;change&#39;); }); }); &quot; ) ), actionButton(&quot;button1&quot;, icon(&quot;plus&quot;)), actionButton(&quot;button2&quot;, uiOutput(&quot;val&quot;)), actionButton(&quot;reset&quot;, icon(&quot;undo&quot;)), plotOutput(&quot;plot&quot;) ) server &lt;- function(input, output) { output$val &lt;- renderUI({ paste(&quot;Value: &quot;, input$button2) }) output$plot &lt;- renderPlot({ validate(need(input$button2 &gt;= 10, message = &quot;Only visible after 10 clicks on the second button&quot;)) hist(rnorm(100)) }) observeEvent(input$button2, { if (input$button2 == 0) { showNotification( &quot;Button successfuly reset&quot;, type = &quot;warning&quot; ) } }) } shinyApp(ui, server) This trick has been extensively used in the virtual physiology simulator to trigger animations. 9.2.5 Binding other elements 9.2.5.1 {shinydashboard} boxes on steroids The Shiny input binding system is too convenient to be only used it for input elements. In {shinydashboard}, you may know the box function. Boxes are containers with a title, body, footer, as well as optional elements. It would be nice to capture the state of the box in an input, so as to trigger other actions as soon as this input changes. Since an input value is unique, we must add an inputId parameter to the box function. You may inspect the code here. Since we may collapse and uncollapse the box, we create the updateBox2 function, which will toggle it: updateBox2 &lt;- function(inputId, session = getDefaultReactiveDomain()) { session$sendInputMessage(inputId, message = NULL) } When collapsed, a box gets the collapsed-box class. Note: this will be useful for the input binding. As mentioned above, it is also necessary to know when to tell Shiny to update the value with the subscribe method. Most of the time, the change event might be sufficient, but as shinydashboard is built on top of AdminLTE2, it has an API to control the box behavior. We identify 2 events corresponding to the collapsible action: expanded.boxwidget (Triggered after the box is expanded) collapsed.boxwidget (Triggered after the box is collapsed) Unfortunately, after further investigations, those events are not possible to use since the AdminLTE code does not trigger them in the main JS code (see the collapse method line 577-612). There are other solutions, as shown below with the click event. To toggle the box, we use the toggleBox method. let boxBinding = new Shiny.InputBinding(); $.extend(boxBinding, { find: function(scope) { return $(scope).find(&#39;.box&#39;); }, getValue: function(el) { let isCollapsed = $(el).hasClass(&#39;collapsed-box&#39;) return {collapsed: isCollapsed}; // this will be a list in R }, setValue: function(el, value) { $(el).toggleBox(); }, receiveMessage: function(el, data) { this.setValue(el, data); $(el).trigger(&#39;change&#39;); }, subscribe: function(el, callback) { $(el).on(&#39;click&#39;, &#39;[data-widget=&quot;collapse&quot;]&#39;, function(event) { setTimeout(function() { callback(); }, 550); }); $(el).on(&#39;change&#39;, function(event) { setTimeout(function() { callback(); }, 550); }); }, unsubscribe: function(el) { $(el).off(&#39;.boxBinding&#39;); } }); Shiny.inputBindings.register(boxBinding, &#39;box-input&#39;); Some comments about the binding: getValue returns an object which will give a list in R. This is in case we add other elements like the remove action available in AdminLTE setValue calls the plug and play toggleBox method receiveMessage must trigger a change event so that Shiny knows when the value needs to be updated subscribe listens to the click event on the [data-widget=\"collapse\"] element and delays the callback call by a value which is slightly higher than the default AdminLTE2 animation to collapse the box (500mx). If you omit this part, the input will not have time to properly update!!! We don’t need an extra listener for the updateBox2 function since it also triggers a click on the collapse button, thereby forwarding to the corresponding listener Let’s try our new toy in a simple dashboard: ui &lt;- fluidPage( # import shinydashboard deps without the need of the dashboard template useShinydashboard(), tags$style(&quot;body { background-color: ghostwhite};&quot;), br(), box2( title = textOutput(&quot;box_state&quot;), &quot;Box body&quot;, inputId = &quot;mybox&quot;, collapsible = TRUE, plotOutput(&quot;plot&quot;) ), actionButton(&quot;toggle_box&quot;, &quot;Toggle Box&quot;, class = &quot;bg-success&quot;) ) server &lt;- function(input, output, session) { output$plot &lt;- renderPlot({ req(!input$mybox$collapsed) plot(rnorm(200)) }) output$box_state &lt;- renderText({ state &lt;- if (input$mybox$collapsed) &quot;collapsed&quot; else &quot;uncollapsed&quot; paste(&quot;My box is&quot;, state) }) observeEvent(input$toggle_box, { updateBox2(&quot;mybox&quot;) }) } shinyApp(ui, server) 9.2.5.2 Faster boxes Even though animations are nice, it appears rather sub-optimal to wait 500 ms for a box to collapse. AdminLTE options allow to change this through the $.AdminLTE.boxWidget object. We specify the animationSpeed property to 10 milliseconds and update the input binding script to reduce the delay in the subscribe method (50 ms seems reasonable). To get a comparison try to run the example below. # You&#39;ll need the devel version of shinydashboardPlus #remotes::install_github(&quot;RinteRface/shinydashboardPlus&quot;) library(shiny) library(shinydashboard) library(shinydashboardPlus) ui &lt;- dashboardPagePlus( dashboardHeaderPlus(), dashboardSidebar(), dashboardBody( tags$style(&quot;body { background-color: ghostwhite}&quot;), actionButton(&quot;toggle_box&quot;, &quot;Toggle Box&quot;), br(), boxPlus( title = textOutput(&quot;box_state&quot;), &quot;Box body&quot;, inputId = &quot;mybox&quot;, collapsible = TRUE, closable = TRUE, plotOutput(&quot;plot&quot;) ) ) ) server &lt;- function(input, output, session) { output$plot &lt;- renderPlot({ req(!input$mybox$collapsed) plot(rnorm(200)) }) output$box_state &lt;- renderText({ state &lt;- if (input$mybox$collapsed) &quot;collapsed&quot; else &quot;uncollapsed&quot; paste(&quot;My box is&quot;, state) }) observeEvent(input$toggle_box, { updateBoxPlus(&quot;mybox&quot;, action = &quot;toggle&quot;) }) observeEvent(input$mybox$collapsed, { collapsed &lt;- if (input$mybox$collapsed) &quot;collapsed&quot; else &quot;uncollapsed&quot; message &lt;- paste(&quot;My box is&quot;, collapsed) showNotification(message, type = &quot;warning&quot;, duration = 1) }) } shinyApp(ui, server) 9.3 Utilities to quickly define new inputs 9.3.1 Introduction If you ever wondered where the Shiny.onInputChange or Shiny.setInputValue comes from (see article), it is actually defined in the initShiny function. exports.setInputValue = exports.onInputChange = function(name, value, opts) { opts = addDefaultInputOpts(opts); inputs.setInput(name, value, opts); }; Briefly, this function avoids creating an input binding. It is faster to code but there is a price to pay: losing the ability to easily update the new input. Indeed, all input functions like sliderInput have their own update function like updateSliderInput, because of the custom input binding system (We will see it very soon)! 9.3.2 Examples Shiny.setInputValues becomes powerful when combined to the numerous Shiny JavaScript events listed here. This is what we use in the shinyMobile package to store the current device information in a shiny input. Briefly, Framework7 (on top of which is built shinyMobile) has a method Framework7.device, which gives many details related to the user device. $(document).on(&#39;shiny:connected&#39;, function(event) { Shiny.setInputValue(&#39;deviceInfo&#39;, Framework7.device); }); This allows to conditionally display elements and deeply customize the interface. In the example below, the card will not show on mobile devices. library(shinyMobile) shinyApp( ui = f7Page( title = &quot;My app&quot;, f7SingleLayout( navbar = f7Navbar( title = &quot;shinyMobile info&quot;, hairline = FALSE, shadow = TRUE ), # main content uiOutput(&quot;card&quot;), verbatimTextOutput(&quot;info&quot;), ) ), server = function(input, output, session) { output$info &lt;- renderPrint(input$shinyInfo) # generate a card only for desktop output$card &lt;- renderUI({ if (!input$deviceInfo$desktop) { f7Card( &quot;This is a simple card with plain text, but cards can also contain their own header, footer, list view, image, or any other element.&quot; ) } else { f7Toast( session, &quot;You are on desktop! The card will not display&quot;, position = &quot;center&quot; ) } }) } ) 9.3.3 Custom data format In some cases, the automatic Shiny R to JS data management may not meet our needs. For instance, assume we create a date in JS with new Date() and store it in a shiny input with Shiny.setInputValue. On the R side, we will not obtain a date but a character, which is not convenient. This is where input handlers are useful since they allow to manipulate data generated on the JS side before injecting them in R. Such handlers are created with shiny::registerInputHandler that takes 2 parameters: type allows to connect the handler to Shiny.setInputValue. Note that the id is followed by the handler type, for instance Shiny.setInputValue('test:handler', ...) is connected to shiny::registerInputHandler('handler', ...) a function to transform data, having data as main parameter Below I exceptionally include JS code directly in the shiny app snippet, which is not best practice but convenient for the demonstration. Only the second input will give the correct result. # You must click on the window to create inputs!! registerInputHandler(&quot;textDate&quot;, function(data, ...) { if (is.null(data)) { NULL } else { res &lt;- try(as.Date(unlist(data)), silent = TRUE) if (&quot;try-error&quot; %in% class(res)) { warning(&quot;Failed to parse dates!&quot;) # as.Date(NA) data } else { res } } }, force = TRUE) ui &lt;- fluidPage( tags$script( &quot;$(function(){ $(window).on(&#39;click&#39;, function() { var currentTime = new Date(); Shiny.setInputValue(&#39;time1&#39;, currentTime); Shiny.setInputValue(&#39;time2:textDate&#39;, currentTime); }); }); &quot; ), verbatimTextOutput(&quot;res1&quot;), verbatimTextOutput(&quot;res2&quot;) ) server &lt;- function(input, output, session) { output$res1 &lt;- renderPrint(list(class(input$time1), input$time1)) output$res2 &lt;- renderPrint(list(class(input$time2), input$time2)) } shinyApp(ui, server) 9.4 Hidden gems about inputs We present some tools that may be useful…TO FINISH 9.4.1 Get access to initial values Something we may notice when exploring the initShiny function is the existence of a Shiny.shinyapp object, defined as follows: var shinyapp = exports.shinyapp = new ShinyApp(); Let’s explore what shinyApp contains. The definition is located in the shinyapps.js script. var ShinyApp = function() { this.$socket = null; // Cached input values this.$inputValues = {}; // Input values at initialization (and reconnect) this.$initialInput = {}; // Output bindings this.$bindings = {}; // Cached values/errors this.$values = {}; this.$errors = {}; // Conditional bindings (show/hide element based on expression) this.$conditionals = {}; this.$pendingMessages = []; this.$activeRequests = {}; this.$nextRequestId = 0; this.$allowReconnect = false; }; It creates several properties, some of them are easy to guess like inputValues or initialInput. Let’s run the example below and open the HTML inspector. Notice that the sliderInput is set to 500 at t0 (initialization). ui &lt;- fluidPage( sliderInput(&quot;obs&quot;, &quot;Number of observations:&quot;, min = 0, max = 1000, value = 500 ), plotOutput(&quot;distPlot&quot;) ) server &lt;- function(input, output, session) { output$distPlot &lt;- renderPlot({ hist(rnorm(input$obs)) }) } shinyApp(ui, server) Figure 9.7 shows how to access Shiny’s initial input value with Shiny.shinyapp.$initialInput.obs. After changing the slider position, its value is given by Shiny.shinyapp.$inputValues.obs. $initialInput and $inputValues contains many more elements, however we are only interested in the slider function in this example. FIGURE 9.7: Explore initial input values 9.4.2 Get the last changed input 9.4.2.1 Motivations We probably all had this question one day: How can I get the last changed input in Shiny? There are already some methods like this one provided by Dean Attali. runApp( shinyApp( ui = shinyUI( fluidPage( textInput(&#39;txt_a&#39;, &#39;Input Text A&#39;), textInput(&#39;txt_b&#39;, &#39;Input Text B&#39;), uiOutput(&#39;txt_c_out&#39;), verbatimTextOutput(&quot;show_last&quot;) ) ), server = function(input, output, session) { output$txt_c_out &lt;- renderUI({ textInput(&#39;txt_c&#39;, &#39;Input Text C&#39;) }) values &lt;- reactiveValues( lastUpdated = NULL ) observe({ lapply(names(input), function(x) { observe({ input[[x]] values$lastUpdated &lt;- x }) }) }) output$show_last &lt;- renderPrint({ values$lastUpdated }) } ) ) Shouldn’t this be easier? Could we do that from the client instead, thereby reducing the server load? 9.4.2.2 JavaScript, my friend Here comes our friend, JavaScript. If you insert this snippet in the head of your app, you will be able to get the last changed input (name, value and type). $(document).on(&#39;shiny:inputchanged&#39;, function(event) { Shiny.setInputValue(&#39;pleaseStayHome&#39;, {name: event.name, value: event.value, type: event.binding.name.split(&#39;.&#39;)[1]}); }); If you use this code in a custom shiny template, it is possible that input bindings don’t have name, which would thereby make event.binding.name.split('.')[1] crash because event.binding is undefined. If so, you may remove this part: $(document).on(&#39;shiny:inputchanged&#39;, function(event) { Shiny.setInputValue(&#39;pleaseStayHome&#39;, {name: event.name, value: event.value}); }); 9.4.2.3 Example {shinyMobile} natively implements this feature that may be accessed with input$lastInputChanged. library(shinyMobile) shinyApp( ui = f7Page( title = &quot;My app&quot;, f7SingleLayout( navbar = f7Navbar( title = &quot;Single Layout&quot;, hairline = FALSE, shadow = TRUE ), toolbar = f7Toolbar( position = &quot;bottom&quot;, f7Link(label = &quot;Link 1&quot;, src = &quot;https://www.google.com&quot;), f7Link(label = &quot;Link 2&quot;, src = &quot;https://www.google.com&quot;, external = TRUE) ), # main content, f7Card( f7Text(inputId = &quot;text&quot;, label = &quot;Text&quot;), f7Slider(inputId = &quot;range1&quot;, label = &quot;Range&quot;, min = 0, max = 2, value = 1, step = 0.1), f7Stepper(inputId = &quot;stepper1&quot;, label = &quot;Stepper&quot;, min = 0, max = 10, value = 5), verbatimTextOutput(&quot;lastChanged&quot;) ) ) ), server = function(input, output) { output$lastChanged &lt;- renderPrint(input$lastInputChanged) } ) This approach has the advantage not to overload the server part with complex logic. 9.4.2.4 About {shinylogs} The {shinylogs} package developed by dreamRs contains this feature with much more advanced options. library(shinylogs) shinyApp( ui = fluidPage( numericInput(&quot;n&quot;, &quot;n&quot;, 1), sliderInput(&quot;s&quot;, &quot;s&quot;, min = 0, max = 10, value = 5), verbatimTextOutput(&quot;lastChanged&quot;) ), server = function(input, output, session) { # specific to shinylogs track_usage(storage_mode = store_null()) output$lastChanged &lt;- renderPrint(input$`.shinylogs_lastInput`) } ) "],
["shiny-custom-handler.html", "Chapter 10 Custom handlers: from R to JavaScript", " Chapter 10 Custom handlers: from R to JavaScript Shiny provides tools to ease the communication between R and JavaScript, as illustrated in section 8.1. How does R send messages to JavaScript? We already discussed the usage of sendInputMessage() in the input binding section 9. The other important method is sendCustomMessage(type, message). It works by pair with the JS method Shiny.AddCustomMessageHandler, linked with the type parameter. say_hello_to_js &lt;- function(text, session = getDefaultReactiveDomain()) { session$sendCustomMessage(type = &#39;say-hello&#39;, message = text) } The JavaScript receptor is defined below: $(function() { Shiny.AddCustomMessageHandler(&#39;say-hello&#39;, function(message) { alert(`R says ${message} to you!`) }); }); The shiny app below will simply print a welcome message every 5 seconds. We obviously set options(shiny.trace = TRUE). Figure 10.1 summarizes the main mechanisms involved in the R to JS communication. The corresponding code may be found here. shinyAppDir(system.file(&quot;chapter6/say_hello&quot;, package = &quot;OSUICode&quot;)) You will find a whole chapter dedicated to custom handlers here 16. FIGURE 10.1: From R to JavaScript Combining Shiny.setInputValue, Shiny.addCustomMessageHandler, here is a fun example that sets the body background as a result of a simple button click. We defined 3 JS pieces: getPokemon whose script is adapted from Colin Fay et al. (see here). This function fetch the pokeapi data and if successful set an input value, which will be available on the R side An event listener is set to the only button of the page so that each time we click, we call getPokemon to select a random background image input$pokeData is actually a quite complex list (deeply nested JSON) and some manipulation is done from R in the observeEvent block. Once done, we send the data back to JS through the websocket (the session object sends a message). On the JS side, the last block is a custom message handler that will add some inline CSS properties to the body element library(shiny) ui &lt;- fluidPage( tags$script( HTML( &quot;$(function() { // Taken from Colin const getPokemon = () =&gt; { // FETCHING THE API DATA let randId = Math.floor(Math.random() * (+151 + 1 - +1)) + +1; fetch(&#39;https://pokeapi.co/api/v2/pokemon/&#39; + randId) // DEFINE WHAT HAPPENS WHEN JAVASCRIPT RECEIVES THE DATA .then((data) =&gt;{ // TURN THE DATA TO JSON data.json().then((res) =&gt; { // SEND THE JSON TO R Shiny.setInputValue(&#39;pokeData&#39;, res, {priority: &#39;event&#39;}) }) }) // DEFINE WHAT HAPPENS WHEN THERE IS AN ERROR FETCHING THE API .catch((error) =&gt; { alert(&#39;Error catching result from API&#39;) }) }; // add event listener $(&#39;#button&#39;).on(&#39;click&#39;, function() { getPokemon(); }); // update background based on R data Shiny.addCustomMessageHandler(&#39;update_background&#39;, function(message) { $(&#39;body&#39;).css({ &#39;background-image&#39;:&#39;url(&#39; + message +&#39;)&#39;, &#39;background-repeat&#39;:&#39;no-repeat&#39; }); }); }); &quot; ) ), tags$button(id = &quot;button&quot;, &quot;Go!&quot;, class = &quot;btn-success&quot;) ) server &lt;- function(input, output, session) { observeEvent(input$pokeData, { background &lt;- input$pokeData$sprites$other$`official-artwork`$front_default message(background) session$sendCustomMessage(type = &quot;update_background&quot;, message = background) }) } shinyApp(ui, server) "],
["custom-templates-selection.html", "Chapter 11 Template selection", " Chapter 11 Template selection There are numerous HTML templates all over the web. However, few may be suitable for shiny. shiny is built on top of Bootstrap 3 (HTML, CSS and Javascript framework), and changing the framework will not be a trivial endeavor. However, shinymaterial and shiny.semantic are good examples that show this is possible. shiny relies on jQuery (currently v 3.4.1 for shiny). Consequently, all templates based upon React, Vue and other Javascript framework will not be natively supported. Again, there exist some examples for React with shiny and more generally, the reactR package developed by Kent Russell and Alan Dipert from RStudio. See the github repository for more details about all dependencies related to the shiny package. Notes: As shiny depends on Bootstrap 3.4.1, we recommend the user whom is interested in experimenting with Bootstrap 4 to be consciously aware of the potential incompatibilities. See a working example here with bs4Dash. A good source of open source HTML templates is Colorlib and Creative Tim. In the next chapter, we will focus on the tabler.io dashboard template (See Figure 11.1). FIGURE 11.1: Tabler dashboard overview "],
["custom-templates-dependencies.html", "Chapter 12 Define dependencies 12.1 Discover the project 12.2 Identify mandatory dependencies 12.3 Bundle dependencies", " Chapter 12 Define dependencies The Tabler template is a tiny Bootstrap 4 dashboard template. In this chapter, we will describe how to customize Tabler by providing an R wrapper. In this way, the underlying JavaScript code is left untouched yet we are able to incorporate greater functionality. 12.1 Discover the project The first step of any template adaptation consists of exploring the underlying Github repository (if open source) and look for mandatory elements, like CSS/JS dependencies. This is a similar strategy if you want to incorporate an htmlWidget as well. FIGURE 12.1: Github project exploration As shown in Figure 12.1, the most important folders are: dist: contains CSS and JS files as well as other libraries like Bootstrap and jQuery. It is also a good moment to look at the version of each dependency that might conflict with Shiny demo is the website folder used for demonstration purpose. This is our source to explore the template capabilities in depth The scss and build folder may be used to customize the tabler template directly. However as stated above, directions on how to do so are out of scope for this book. 12.2 Identify mandatory dependencies Bootstrap 4, jQuery, tabler.min.css and tabler.min.js are key elements for the template, contrary to flag icons which are optional (and take a lot of space). If your goal is to release your template on CRAN, be mindful of the 5 Mb maximum size limit. From personal experience, I can attest that this is quite challenging to manage. To inspect dependencies, we proceed as follows Download or clone the Github repository Go to the demo folder and open the layout-dark.html file Open the HTML inspector As depicted in Figure ?? left-hand side, we need to include the tabler.min.css from the header. If you are not convinced, try to remove it from the DOM and see what happens. jqvmap is actually related to an external visualization plugin used in the demo. Finally the demo.min.css file is for the demo purpose. This will not prevent the template from working, so we will skip it for now. So far so good, we only need one file thus! JavaScript dependencies are shown on the right-hand side and located at the end of the body tag. Because we will not need all chart-related dependencies like apexcharts, jquery.vmap and vmap world and may safely ignore them. We will keep the Bootstrap 4 bundle.js, jQuery core and tabler.min.js (the order is crucial). 12.3 Bundle dependencies With the help of the htmltoolsDependency function, we are going to create our main Tabler HTML dependency containing all assets to allow our template to render properly. In this example, I am going to cheat a bit: instead of handling local files, I will use a CDN (content delivery network) that hosts all necessary Tabler assets. This avoids to include all the necessary files in the R package, as well as in a github repository. tablers_deps &lt;- htmlDependency( name = &quot;tabler&quot;, version = &quot;1.0.7&quot;, # we take that of tabler, src = c(href = &quot;https://cdn.jsdelivr.net/npm/tabler@1.0.0-alpha.7/dist/&quot;), script = &quot;js/tabler.min.js&quot;, stylesheet = &quot;css/tabler.min.css&quot; ) I advise the reader to create one HTML dependency per element. The Bootstrap version is v4.3.1 (Shiny relies on 3.4.1) and jQuery is 3.5.0 (Shiny relies on 3.4.1). We can also use a CDN: bs4_deps &lt;- htmlDependency( name = &quot;Bootstrap&quot;, version = &quot;4.3.1&quot;, src = c(href = &quot;https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/&quot;), script = &quot;bootstrap.bundle.min.js&quot; ) jQuery_deps &lt;- htmlDependency( name = &quot;jquery&quot;, version = &quot;3.5.0&quot;, src = c(href = &quot;https://code.jquery.com/&quot;), script = &quot;jquery-3.5.0.slim.min.js&quot; ) We finally create our dependency manager: # add all dependencies to a tag. Don&#39;t forget to set append to TRUE to preserve any existing dependency add_tabler_deps &lt;- function(tag) { # below, the order is of critical importance! deps &lt;- list(bs4_deps, tablers_deps) attachDependencies(tag, deps, append = TRUE) } Notice the dependencies order in the deps list: this will be exactly the same order in the head of the HTML page. Some libraries require to be loaded at a specific place, like the Tabler dependencies which must come after Bootstrap. It is not surprising since Tabler is built on top of Bootstrap 4. Let’s see how to use add_tabler_deps. We consider a &lt;div&gt; placeholder and check for its dependencies with findDependencies (should be NULL). Then, we wrap it with add_tabler_deps. tag &lt;- div() findDependencies(tag) ## NULL tag &lt;- add_tabler_deps(div()) findDependencies(tag) ## [[1]] ## List of 10 ## $ name : chr &quot;Bootstrap&quot; ## $ version : chr &quot;4.3.1&quot; ## $ src :List of 1 ## ..$ href: chr &quot;https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/&quot; ## $ meta : NULL ## $ script : chr &quot;bootstrap.bundle.min.js&quot; ## $ stylesheet: NULL ## $ head : NULL ## $ attachment: NULL ## $ package : NULL ## $ all_files : logi TRUE ## - attr(*, &quot;class&quot;)= chr &quot;html_dependency&quot; ## ## [[2]] ## List of 10 ## $ name : chr &quot;tabler&quot; ## $ version : chr &quot;1.0.7&quot; ## $ src :List of 1 ## ..$ href: chr &quot;https://cdn.jsdelivr.net/npm/tabler@1.0.0-alpha.7/dist/&quot; ## $ meta : NULL ## $ script : chr &quot;js/tabler.min.js&quot; ## $ stylesheet: chr &quot;css/tabler.min.css&quot; ## $ head : NULL ## $ attachment: NULL ## $ package : NULL ## $ all_files : logi TRUE ## - attr(*, &quot;class&quot;)= chr &quot;html_dependency&quot; As shown above, our dependencies are applied to the div, in the correct order. This order is set by the list list(bs4_deps, jQuery_deps, tablers_deps) and allows use to avoid potential conflicts. If we try to run this simple tag in a shiny app, we notice that all dependencies are added to the &lt;head&gt; tag, whereas the original template loads JavaScript dependencies in the &lt;body&gt;. Unfortunately, htmltools does not allow developers to distribute dependencies in different places. Here there is no impact but for other templates like Framework7 (which is powering shinyMobile), JavaScript must be place in the body. In practice, this is challenging to guess and may only be solved by manual testing. ui &lt;- fluidPage(tag) server &lt;- function(input, output, session) {} shinyApp(ui, server) Even though the add_tabler_deps function may be applied to any tag, we will use it with the core HTML template, that remain to be designed! Would you like to see if our dependency system works? Let’s meet in the next chapter to design the main dashboard layout. "],
["custom-templates-skeleton.html", "Chapter 13 Template skeleton 13.1 Identify template elements 13.2 Design the page layout 13.3 Exercises", " Chapter 13 Template skeleton The list of all available layouts is quite impressive (horizontal, vertical, compressed, right to left, dark, …). In the next steps, we will focus on the dark-compressed template. We leave the reader to try other templates as an exercise. 13.1 Identify template elements We are quite lucky since there is nothing fancy about the tabler layout. As usual, let’s inspect the layout-condensed-dark.html (in the tabler /demo folder) in Figure 13.1 FIGURE 13.1: Tabler condensed layout There are 2 main components: - the header containing the brand logo, the navigation and dropdown - the content containing the dashboard body as well as the footer Something important: the dashboard body does not mean &lt;body&gt; tag! This is all! 13.2 Design the page layout 13.2.1 The page wrapper Do you remember the structure of a basic html page seen in Chapter 2.2? Well, if not, here is a reminder. &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;!-- head content here --&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;Hello World&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; We actually don’t need to include the &lt;html&gt; tag since shiny will automatically do it. Below we construct a list of tags with tagList, including the head and the body. In the head we have the meta tags which has multiple purposes: describe the encoding, how to display the app on different devices. For instance apple-mobile-web-app-status-bar-style is for iOS devices mobile support. Set the favicon, which is an icon representing the website icon, that is the one you may see on the right side of the searchbar. Try twitter for instance. The page title and favicon may be changed by the developer, so they may be included as parameters of the function. If you remember, there also should be CSS in the head but nothing here! Actually, the insertion of dependencies will be achieved by our addDeps function defined in Chapter 12. Tabler comes with 2 main themes, namely white and dark, which may be applied through the &lt;body&gt; class attribute (respectively “antialiased theme-dark” and “antialiased”). The … parameter contain other template elements like the header and the dashboard body, that remain to be created. As shown in Figure 11.1 of Chapter 11, the tabler dashboard template may contain a navigation bar and a footer. As they are not mandatory, we will not create dedicated parameters and pass all elements in the …slot. tabler_page &lt;- function(..., dark = TRUE, title = NULL, favicon = NULL){ # head head_tag &lt;- tags$head( tags$meta(charset = &quot;utf-8&quot;), tags$meta( name = &quot;viewport&quot;, content = &quot; width=device-width, initial-scale=1, viewport-fit=cover&quot; ), tags$meta(`http-equiv` = &quot;X-UA-Compatible&quot;, content = &quot;ie=edge&quot;), tags$title(title), tags$link( rel = &quot;preconnect&quot;, href = &quot;https://fonts.gstatic.com/&quot;, crossorigin = NA ), tags$meta(name = &quot;msapplication-TileColor&quot;, content = &quot;#206bc4&quot;), tags$meta(name = &quot;theme-color&quot;, content = &quot;#206bc4&quot;), tags$meta(name = &quot;apple-mobile-web-app-status-bar-style&quot;, content = &quot;black-translucent&quot;), tags$meta(name = &quot;apple-mobile-web-app-capable&quot;, content = &quot;yes&quot;), tags$meta(name = &quot;mobile-web-app-capable&quot;, content = &quot;yes&quot;), tags$meta(name = &quot;HandheldFriendly&quot;, content = &quot;True&quot;), tags$meta(name = &quot;MobileOptimized&quot;, content = &quot;320&quot;), tags$meta(name = &quot;robots&quot;, content = &quot;noindex,nofollow,noarchive&quot;), tags$link(rel = &quot;icon&quot;, href = favicon, type = &quot;image/x-icon&quot;), tags$link(rel = &quot;shortcut icon&quot;, href = favicon, type=&quot;image/x-icon&quot;) ) # body body_tag &lt;- tags$body( tags$div( class = paste0(&quot;antialiased &quot;, if(dark) &quot;theme-dark&quot;), style = &quot;display: block;&quot;, tags$div(class = &quot;page&quot;, ...) ) ) %&gt;% add_tabler_deps() tagList(head_tag, body_tag) } Below we quickly test if a tabler element renders well which confirms our setup is adequate. To do this, we include a random tabler element taken from the demo html page, using HTML. Let’s be clear: you should avoid as much as possible using HTML because of security issues. This also checks that our basic Shiny input/output system works as expected with a sliderInput linked to a plot output. #thematic_on() #onStop(thematic_off) ui &lt;- tabler_page( &quot;test&quot;, sliderInput(&quot;obs&quot;, &quot;Number of observations:&quot;, min = 0, max = 1000, value = 500 ), plotOutput(&quot;distPlot&quot;), br(), HTML( &#39;&lt;div class=&quot;col-sm-6 col-lg-3&quot;&gt; &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;div class=&quot;d-flex align-items-center&quot;&gt; &lt;div class=&quot;subheader&quot;&gt;Sales&lt;/div&gt; &lt;div class=&quot;ml-auto lh-1&quot;&gt; &lt;div class=&quot;dropdown&quot;&gt; &lt;a class=&quot;dropdown-toggle text-muted&quot; href=&quot;#&quot; data-toggle=&quot;dropdown&quot; aria-haspopup=&quot;true&quot; aria-expanded=&quot;false&quot;&gt; Last 7 days &lt;/a&gt; &lt;div class=&quot;dropdown-menu dropdown-menu-right&quot;&gt; &lt;a class=&quot;dropdown-item active&quot; href=&quot;#&quot;&gt;Last 7 days&lt;/a&gt; &lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;Last 30 days&lt;/a&gt; &lt;a class=&quot;dropdown-item&quot; href=&quot;#&quot;&gt;Last 3 months&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;h1 mb-3&quot;&gt;75%&lt;/div&gt; &lt;div class=&quot;d-flex mb-2&quot;&gt; &lt;div&gt;Conversion rate&lt;/div&gt; &lt;div class=&quot;ml-auto&quot;&gt; &lt;span class=&quot;text-green d-inline-flex align-items-center lh-1&quot;&gt; 7% &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; class=&quot;icon ml-1&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; stroke-width=&quot;2&quot; stroke=&quot;currentColor&quot; fill=&quot;none&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot;&gt; &lt;path stroke=&quot;none&quot; d=&quot;M0 0h24v24H0z&quot;&gt;&lt;/path&gt; &lt;polyline points=&quot;3 17 9 11 13 15 21 7&quot;&gt;&lt;/polyline&gt; &lt;polyline points=&quot;14 7 21 7 21 14&quot;&gt;&lt;/polyline&gt; &lt;/svg&gt; &lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;progress progress-sm&quot;&gt; &lt;div class=&quot;progress-bar bg-blue&quot; style=&quot;width: 75%&quot; role=&quot;progressbar&quot; aria-valuenow=&quot;75&quot; aria-valuemin=&quot;0&quot; aria-valuemax=&quot;100&quot;&gt; &lt;span class=&quot;sr-only&quot;&gt;75% Complete&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &#39; ), title = &quot;Tabler test&quot; ) server &lt;- function(input, output) { output$distPlot &lt;- renderPlot({ hist(rnorm(input$obs)) }) } shinyApp(ui, server) Ok, our info card and the shiny element work like a charm, which is a good start. Now we may focus on the aesthetics. 13.2.2 The body content In this part, we translate the dashboard body HTML code to R. As a reminder, the html2r by Alan Dipert substantially speeds up the conversion process. You copy the code in the HTML text area, click on convert and get the R shiny output. We create a function called tabler_body. The … parameter holds all the dashboard body elements and the footer is dedicated for the future tabler_footer function. tabler_body &lt;- function(..., footer = NULL) { div( class = &quot;content&quot;, div(class = &quot;container-xl&quot;, ...), tags$footer(class = &quot;footer footer-transparent&quot;, footer) ) } Let’s test it with the previous example. ui &lt;- tabler_page(tabler_body(h1(&quot;Hello World&quot;))) server &lt;- function(input, output) {} shinyApp(ui, server) Way better! 13.2.3 The footer The footer is composed of a left and right containers. We decide to create parameters left and right in which the user will be able to pass any elements. tabler_footer &lt;- function(left = NULL, right = NULL) { div( class = &quot;container&quot;, div( class = &quot;row text-center align-items-center flex-row-reverse&quot;, div(class = &quot;col-lg-auto ml-lg-auto&quot;, right), div(class = &quot;col-12 col-lg-auto mt-3 mt-lg-0&quot;, left) ) ) } All the class attributes are taken from the original HTML template. If you are already familiar with Bootstrap 4, you may easily customize the style. In short, row means that all elements will be aligned on a row, text-center amd align-items-center handle the text and content centering. flex-row-reverse display elements in a reversed order. Notice also that a row element contains columns created with the col class. The Bootstrap grid system relies on the Flexible Box Module, also known as flexbox. As above, let’s check our brand new element. ui &lt;- tabler_page( tabler_body( p(&quot;Hello World&quot;), footer = tabler_footer( left = &quot;Rstats, 2020&quot;, right = a(href = &quot;https://www.google.com&quot;, &quot;More&quot;) ) ) ) server &lt;- function(input, output) {} shinyApp(ui, server) 13.2.4 The navbar (or header) This function is called tabler_header. In the Tabler template, the header has the navbar navbar-expand-md navbar-light classes. We don’t need the navbar-light class since we are only interested in the dark theme. As shown in Figure 13.2, the navbar is composed of 4 elements: the navbar toggler is only visible when we reduce the screen width, like on mobile devices the brand image the navigation the dropdown menus (this is not mandatory) FIGURE 13.2: Tabler header structure You may have a look at the Bootstrap 4 documentation for extra configuration and layout. Each of these element will be considered as an input parameter to the tabler_navbar function, except the navbar toggler which is a default element and must not be removed. Morever, we will only show the brand element when it is provided. The … parameter is a slot for extra elements (between the menu and dropdowns). In the following, we start by creating the main container, that is header_tag and its unique child container_tag. The latter has 4 children toggler_tag, brand_tag, dropdown_tag and navmenu_tag. In this situations, {htmltools} functions like tagAppendChild and tagAppendChildren are game changers to better organize the code and make it more maintainable. One never knows in advance how much extra feature will be added to that component. Hence being cautious at the very beginning is crucial! tabler_navbar &lt;- function(..., brand_url = NULL, brand_image = NULL, nav_menu, nav_right = NULL) { header_tag &lt;- tags$header(class = &quot;navbar navbar-expand-md&quot;) container_tag &lt;- tags$div(class = &quot;container-xl&quot;) # toggler for small devices (must not be removed) toggler_tag &lt;- tags$button( class = &quot;navbar-toggler&quot;, type = &quot;button&quot;, `data-toggle` = &quot;collapse&quot;, `data-target` = &quot;#navbar-menu&quot;, span(class = &quot;navbar-toggler-icon&quot;) ) # brand elements brand_tag &lt;- if (!is.null(brand_url) || !is.null(brand_image)) { a( href = if (!is.null(brand_url)) { brand_url } else { &quot;#&quot; }, class = &quot;navbar-brand navbar-brand-autodark d-none-navbar-horizontal pr-0 pr-md-3&quot;, if(!is.null(brand_image)) { img( src = brand_image, alt = &quot;brand Image&quot;, class = &quot;navbar-brand-image&quot; ) } ) } dropdown_tag &lt;- if (!is.null(nav_right)) { div(class = &quot;navbar-nav flex-row order-md-last&quot;, nav_right) } navmenu_tag &lt;- div( class = &quot;collapse navbar-collapse&quot;, id = &quot;navbar-menu&quot;, div( class = &quot;d-flex flex-column flex-md-row flex-fill align-items-stretch align-items-md-center&quot;, nav_menu ), if (length(list(...)) &gt; 0) { div( class = &quot;ml-md-auto pl-md-4 py-2 py-md-0 mr-md-4 order-first order-md-last flex-grow-1 flex-md-grow-0&quot;, ... ) } ) container_tag &lt;- container_tag %&gt;% tagAppendChildren( toggler_tag, brand_tag, dropdown_tag, navmenu_tag ) header_tag %&gt;% tagAppendChild(container_tag) } The navbar menu is the main component of the navbar. The … parameter is a slot for the menu items. Compared to the original tabler dashboard template where there is only the class navbar-nav, we have to add at least, the nav class to make sure items are correctly activated/inactivated. The nav-pills class is to select pills instead of basic tabs (see here), which is nothing more than a cosmetic consideration. Notice the ul tag that will contain li elements, that is the navbar items. tabler_navbar_menu &lt;- function(...) { tags$ul(class = &quot;nav nav-pills navbar-nav&quot;, ...) } Besides, each navbar menu item could be either a simple button or contain multiple menu sub-items. For now, we only focus on simple items. 13.2.4.1 Navbar navigation The navbar is extremely important since it will drive the navigation of the template. We would like to associate each item to a separate page in the body content. This will allow us to go to a new page each time we change an item. In brief, it is very similar to the Shiny tabsetPanel function. In HTML, menu items are &lt;a&gt; tags (links) with a given href attribute pointing to a specific page located in the server files. The point with a Shiny app is that we can’t decide how to split our content into several pages. We only have app.R generating a simple HTML page. The strategy here is to create a tabbed navigation, to mimic multiple pages. Let’s see how tabset navigation works. In the menu list, all items must have: a data-toggle attribute set to tab an href attribute holding a unique id. This unique id is mandatory since it will point the menu item to the corresponding body content. On the body side, tab panels are contained in a tabset panel (simple div container), have a role attribute set to tabpanel and an id corresponding the href passed in the menu item. The exact match between id and href is mandatory, as shown in Figure 13.3. FIGURE 13.3: Tabler tabset main principle Below, we propose a possible implementation of a menu item, as well as the corresponding body tab panel. The text parameter corresponds to the nav item text displayed in the menu. We also added an optional icon and the ability to select the item at start. tabler_navbar_menu_item &lt;- function(text, tabName, icon = NULL, selected = FALSE) { item_cl &lt;- paste0(&quot;nav-link&quot;, if(selected) &quot; active&quot;) tags$li( class = &quot;nav-item&quot;, a( class = item_cl, href = paste0(&quot;#&quot;, tabName), `data-toggle` = &quot;pill&quot;, # see https://getbootstrap.com/docs/4.0/components/navs/ `data-value` = tabName, role = &quot;tab&quot;, span(class = &quot;nav-link-icon d-md-none d-lg-inline-block&quot;, icon), span(class = &quot;nav-link-title&quot;, text) ) ) } We also decided to add a fade transition effect between tabs, as per Bootstrap 4 documentation. tabler_tab_items &lt;- function(...) { div(class = &quot;tab-content&quot;, ...) } tabler_tab_item &lt;- function(tabName = NULL, ...) { div( role = &quot;tabpanel&quot;, class = &quot;tab-pane fade container-fluid&quot;, id = tabName, ... ) } What about testing this in a shiny app? ui &lt;- tabler_page( tabler_navbar( brand_url = &quot;https://preview-dev.tabler.io&quot;, brand_image = &quot;https://preview-dev.tabler.io/static/logo.svg&quot;, nav_menu = tabler_navbar_menu( tabler_navbar_menu_item( text = &quot;Tab 1&quot;, icon = NULL, tabName = &quot;tab1&quot;, selected = TRUE ), tabler_navbar_menu_item( text = &quot;Tab 2&quot;, icon = NULL, tabName = &quot;tab2&quot; ) ) ), tabler_body( tabler_tab_items( tabler_tab_item( tabName = &quot;tab1&quot;, p(&quot;Hello World&quot;) ), tabler_tab_item( tabName = &quot;tab2&quot;, p(&quot;Second Tab&quot;) ) ), footer = tabler_footer( left = &quot;Rstats, 2020&quot;, right = a(href = &quot;https://www.google.com&quot;) ) ) ) server &lt;- function(input, output) {} shinyApp(ui, server) At this point you might argue that we did not even validated the template elements. For instance, going back to the tabler_navbar_menu_item function, we find the following possible issues: What happens if the user provides an invalid tabName, ie a text that is not valid for jQuery like tab&amp;?++? What happens if the user accidentally activates 2 tabs at start? We will see later in Chapter 14 how to validate those parameter. 13.2.4.2 Fine tune tabs behavior Quite good isn’t it? You will notice however that even if the first tab is selected by default, its content is not shown. To fix this, we will apply our jQuery skills. According to the Bootstrap documentation, we must trigger the show event on the active tab at start, as well as add the classes show and active to the associated tab panel in the dashboard body. We therefore target the nav item that has the active class and if no item is found, we select the first item by default and activate its body content. $(function() { // this makes sure to trigger the show event on the active tab at start let activeTab = $(&#39;#navbar-menu .nav-link.active&#39;); // if multiple items are found if (activeTab.length &gt; 0) { let tabId = $(activeTab).attr(&#39;data-value&#39;); $(activeTab).tab(&#39;show&#39;); $(`#${tabId}`).addClass(&#39;show active&#39;); } else { $(&#39;#navbar-menu .nav-link&#39;) .first() .tab(&#39;show&#39;); } }); This script is included in the www folder of the below app. We’ll see in Chapter 15 that custom input binding may perfectly handle this situation and are preferred. #thematic_on() #onStop(thematic_off) # example with custom JS code to activate tabs shinyAppDir(system.file(&quot;chapter12/tabler_tabs&quot;, package = &quot;OSUICode&quot;)) The result is shown in Figure 13.4. I’d also suggest to include at least 1 input/output per tab, to test whether everything works properly. FIGURE 13.4: Tabler template with navbar Looks like we are done for the main template elements. Actually, wouldn’t it be better to include, at least, card containers? 13.2.5 Card containers Card are a central piece of template as they may contain visualizations, metrics and much more. Fortunately, Tabler has a large range of card containers. 13.2.5.1 Classic card What I call a classic card is like the box container of shinydashboard. The card structure has key elements: a width to control the space taken by the card in the Bootstrap grid a title, in general in the header (tabler does always not follow this rule and header is optional) a body where is the main content style elements like color statuses a footer (optional, tabler does not include this) A comprehensive list of all tabler card features may be found here. To be faster, I will copy the following HTML code in the html2R shiny app to convert it to Shiny tags &lt;div class=&quot;col-md-6&quot;&gt; &lt;div class=&quot;card&quot;&gt; &lt;div class=&quot;card-status-top bg-danger&quot;&gt;&lt;/div&gt; &lt;div class=&quot;card-body&quot;&gt; &lt;h3 class=&quot;card-title&quot;&gt;Title&lt;/h3&gt; &lt;p&gt;Some Text.&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; Below is the result. The next step consist in replacing all content by parameters to the tabler_card function, whenever necessary. For instance, the first &lt;div&gt; sets the width of the card. The Bootstrap grid ranges from 0 to 12, so why not creating a width parameter to control the card size. We proceed similarly for the title, status, body content. It seems reasonable to allow title to be NULL (if so, the title will not be shown), same thing for the status. Regarding the card default width, a value of six also makes sense, which would take half of the row. tabler_card &lt;- function(..., title = NULL, status = NULL, width = 6, padding = NULL) { card_cl &lt;- paste0( &quot;card&quot;, if (!is.null(padding)) paste0(&quot; card-&quot;, padding) ) status_tag &lt;- if (!is.null(status)) { div(class = paste0(&quot;card-status-top bg-&quot;, status)) } body_tag &lt;- div( class = &quot;card-body&quot;, # we could have a smaller title like h4 or h5... if (!is.null(title)) { h3(class = &quot;card-title&quot;, title) }, ... ) main_wrapper &lt;- div(class = paste0(&quot;col-md-&quot;, width)) card_wrapper &lt;- div(class = card_cl) card_wrapper &lt;- card_wrapper %&gt;% tagAppendChildren(status_tag, body_tag) main_wrapper %&gt;% tagAppendChild(card_wrapper) } In the meantime, I’d be also nice to be able to display cards in the same row. Let’s create the tabler_row: tabler_row &lt;- function(...) { div(class = &quot;row row-deck&quot;, ...) } Below, we show an example of the tabler_card function, in combination with apexcharter by dreamRs. # test the card data(&quot;economics_long&quot;) economics_long &lt;- economics_long %&gt;% group_by(variable) %&gt;% slice((n()-100):n()) spark_data &lt;- data.frame( date = Sys.Date() + 1:20, var1 = round(rnorm(20, 50, 10)), var2 = round(rnorm(20, 50, 10)), var3 = round(rnorm(20, 50, 10)) ) my_card &lt;- tabler_card( apexchartOutput(&quot;my_chart&quot;), title = &quot;My card&quot;, status = &quot;danger&quot; ) ui &lt;- tabler_page( tabler_body( tabler_row( my_card, tabler_card( apexchartOutput(&quot;spark_box&quot;), title = &quot;My card&quot;, status = &quot;success&quot; ) ) ) ) server &lt;- function(input, output) { output$my_chart &lt;- renderApexchart({ apex(data = economics_long, type = &quot;area&quot;, mapping = aes(x = date, y = value01, fill = variable)) %&gt;% ax_yaxis(decimalsInFloat = 2) %&gt;% # number of decimals to keep ax_chart(stacked = TRUE) %&gt;% ax_yaxis(max = 4, tickAmount = 4) }) output$spark_box &lt;- renderApexchart({ spark_box( data = spark_data[, c(&quot;date&quot;, &quot;var3&quot;)], title = mean(spark_data$var3), subtitle = &quot;Variable 3&quot;, color = &quot;#FFF&quot;, background = &quot;#2E93fA&quot;, title_style = list(color = &quot;#FFF&quot;), subtitle_style = list(color = &quot;#FFF&quot;) ) }) } shinyApp(ui, server) The code output is also shown in Figure 13.5. FIGURE 13.5: Tabler card component 13.2.6 Ribbons: card components Let’s finish this part by including a card component, namely the ribbon. tabler_ribbon &lt;- function(..., position = NULL, color = NULL, bookmark = FALSE) { ribbon_cl &lt;- paste0( &quot;ribbon&quot;, if (!is.null(position)) sprintf(&quot; bg-%s&quot;, position), if (!is.null(color)) sprintf(&quot; bg-%s&quot;, color), if (bookmark) &quot; ribbon-bookmark&quot; ) div(class = ribbon_cl, ...) } Integrating the freshly created ribbon component requires to modify the card structure since the ribbon is added after the body tag, and not parameter is associated with this slot. We could also modify the tabler_card function but htmltools contains tools to help us. Since the ribbon should be put after the card body (but in the card container), we may think about the tagAppendChild function, introduced in Chapter 4: # add the ribbon to a card my_card &lt;- tabler_card(title = &quot;Ribbon&quot;, status = &quot;info&quot;) str(my_card) ## List of 3 ## $ name : chr &quot;div&quot; ## $ attribs :List of 1 ## ..$ class: chr &quot;col-md-6&quot; ## $ children:List of 1 ## ..$ :List of 3 ## .. ..$ name : chr &quot;div&quot; ## .. ..$ attribs :List of 1 ## .. .. ..$ class: chr &quot;card&quot; ## .. ..$ children:List of 2 ## .. .. ..$ :List of 3 ## .. .. .. ..$ name : chr &quot;div&quot; ## .. .. .. ..$ attribs :List of 1 ## .. .. .. .. ..$ class: chr &quot;card-status-top bg-info&quot; ## .. .. .. ..$ children: list() ## .. .. .. ..- attr(*, &quot;class&quot;)= chr &quot;shiny.tag&quot; ## .. .. ..$ :List of 3 ## .. .. .. ..$ name : chr &quot;div&quot; ## .. .. .. ..$ attribs :List of 1 ## .. .. .. .. ..$ class: chr &quot;card-body&quot; ## .. .. .. ..$ children:List of 1 ## .. .. .. .. ..$ :List of 3 ## .. .. .. .. .. ..$ name : chr &quot;h3&quot; ## .. .. .. .. .. ..$ attribs :List of 1 ## .. .. .. .. .. .. ..$ class: chr &quot;card-title&quot; ## .. .. .. .. .. ..$ children:List of 1 ## .. .. .. .. .. .. ..$ : chr &quot;Ribbon&quot; ## .. .. .. .. .. ..- attr(*, &quot;class&quot;)= chr &quot;shiny.tag&quot; ## .. .. .. ..- attr(*, &quot;class&quot;)= chr &quot;shiny.tag&quot; ## .. ..- attr(*, &quot;class&quot;)= chr &quot;shiny.tag&quot; ## - attr(*, &quot;class&quot;)= chr &quot;shiny.tag&quot; my_card$children[[1]] &lt;- my_card$children[[1]] %&gt;% tagAppendChild( tabler_ribbon( icon(&quot;info-circle&quot;, class = &quot;fa-lg&quot;), bookmark = TRUE, color = &quot;red&quot; ) ) As shown above, the ribbon has been successfuly included in the card tag. Now, we check how it looks in a shiny app. ui &lt;- tabler_page( tabler_body( my_card ) ) server &lt;- function(input, output) {} shinyApp(ui, server) FIGURE 13.6: Tabler ribbon component 13.2.7 Icons Not mentionned before but we may include fontawesome icons provided with Shiny, as well as other libraries. Moreover, Tabler has a internal svg library located here. 13.3 Exercises Consider the tab card at the very bottom of the tabler documentation. Propose an implementation of that feature. Have a look at this page. Select 2 elements and create the corresponding R functions. "],
["custom-templates-testing.html", "Chapter 14 Testing and validating templates elements 14.1 Validate template functions 14.2 Testing templates elements 14.3 Testing JavaScript", " Chapter 14 Testing and validating templates elements Until now, we have been building the template boilerplate, that is the main skeleton functions (page, navbar, navbar menu, …) as well as some components such as cards, ribbons, progress bars. We also exposed some techniques to substantially give more interactivity to the template, leveraging our freshly acquired JavaScript skills. Does this mean we are ready to make the template public? Not yet since some essentials steps are missing: Input validation is a crucial step toward success. Briefly, it consists in checking user inputs so that your functions fail safely and elegantly by providing meaningful error messages or warnings. This concept has already been covered in R for Data Science, Advanced R and a lot of other resources. Hence, I am not trying to reinvent the wheel and we will rely on already existing patterns, whose effectiveness is no longer to be demonstrated. Welcome to the defensive programming world! On the other hand, testing components allows to check if a functions does what it is supposed to do. Consequently, it is a proof of robustness, and increases reproducibility. It significantly reduces the mental load when it comes to start code refactoring, thereby making you feel slightly less guilty about creating breaking changes since, most of the time, your tests will be able to capture those error. 14.1 Validate template functions 14.1.1 Create your own validations Below, we will show some examples to validate user inputs. We first consider the tabler_card element from Chapter 13. tabler_card &lt;- function(..., title = NULL, status = NULL, width = 6, stacked = FALSE, padding = NULL) { card_cl &lt;- paste0( &quot;card&quot;, if (stacked) &quot; card-stacked&quot;, if (!is.null(padding)) paste0(&quot; card-&quot;, padding) ) div( class = paste0(&quot;col-md-&quot;, width), div( class = card_cl, if (!is.null(status)) { div(class = paste0(&quot;card-status-top bg-&quot;, status)) }, div( class = &quot;card-body&quot;, # we could have a smaller title like h4 or h5... if (!is.null(title)) { h3(class = &quot;card-title&quot;, title) }, ... ) ) ) } The first thing is to think about what to validate. Here, I see at least 3 test: checking the status value checking the width value checking the padding value Writing validation tests requires knowledge about the underlying mechanisms. In our case, we must know the Bootstrap 4 grid rules and valid color statuses. The Bootstrap 4 grid ranges from 1 to 12. In other words, a card having a width of 12 will take the full page wherease, we may align 3 cards or width 4. Valid statuses are primary, secondary, success, info, danger, warning, light and dark. It is therefore pretty straightforward to validate the card width: it must be numeric and between 1 and 12. Moreover, since the template has other containers including the width parameter, we will create a function validate_width &lt;- function(width) { if (is.numeric(width)) { if (width &lt; 1 || width &gt; 12) { stop(&quot;width must belong to [1, 12], as per Bootstrap 4 grid documentation. See more at https://getbootstrap.com/docs/4.0/layout/grid/&quot;) } } else { stop(&quot;width must be numeric&quot;) } } # validate_width(-1) # validate_width(13) # validate_width(&quot;string&quot;) To check the status parameter, we save the valid statuses in a vector and take the validStatuses function from shinydashboard utils. It also make sense to create a function since this parameter is widely used among template components. Contrary to the shinydashboard function, our custom valid_status does not fail if the status is NULL since it is not a mandatory parameter. valid_statuses &lt;- c( &quot;primary&quot;, &quot;secondary&quot;, &quot;success&quot;, &quot;info&quot;, &quot;warning&quot;, &quot;danger&quot;, &quot;light&quot;, &quot;dark&quot; ) validate_status &lt;- function(status) { if (is.null(status)) { return(TRUE) } else { if (status %in% valid_statuses) { return(TRUE) } } stop(&quot;Invalid status: &quot;, status, &quot;. Valid statuses are: &quot;, paste(valid_statuses, collapse = &quot;, &quot;), &quot;.&quot;) } We finish by the padding validation. According to the Tabler documentation, there are three possible choices, namely sm, md or lg. valid_paddings &lt;- c(&quot;sm&quot;, &quot;md&quot;, &quot;lg&quot;) validate_padding &lt;- function(padding) { if (!is.null(padding)) { if (!(padding %in% valid_paddings)) { stop(&quot;Invalid status: &quot;, padding, &quot;. Valid choices are: &quot;, paste(valid_paddings, collapse = &quot;, &quot;), &quot;.&quot;) } } } We apply all these validation to our card element. tabler_card &lt;- function(..., title = NULL, status = NULL, width = 6, stacked = FALSE, padding = NULL) { validate_status(status) validate_width(width) validate_padding(padding) card_cl &lt;- paste0( &quot;card&quot;, if (stacked) &quot; card-stacked&quot;, if (!is.null(padding)) paste0(&quot; card-&quot;, padding) ) div( class = paste0(&quot;col-md-&quot;, width), div( class = card_cl, if (!is.null(status)) { div(class = paste0(&quot;card-status-top bg-&quot;, status)) }, div( class = &quot;card-body&quot;, # we could have a smaller title like h4 or h5... if (!is.null(title)) { h3(class = &quot;card-title&quot;, title) }, ... ) ) ) } As of R 4.0.0, the stopifnot function may be a good alternative to stop. We recommend to be reasonable and not to validate every single parameter. 14.1.2 Existing utils functions 14.1.2.1 Validating tags The problem with the above approach is that it may take time to create all validation functions. Fortunately, packages like {shinydashboard} include really powerful validation functions, especially tagAssert. This function has been included in the book side package so that you may use it at any time. myTag &lt;- div(class = &quot;bg-blue&quot;) tagAssert(myTag, type = &quot;div&quot;) tagAssert(myTag, type = &quot;li&quot;) # will fail tagAssert(myTag, class = &quot;bg-blue&quot;) Importantly, tagAssert will raise an error if the condition is not fulfilled. Another function, tagMatches simply returns TRUE/FALSE. It looks for ìd, class, name and any other tag attribute like data-value. Like tagAssert, tagMatches is also available in the book side package. tagMatches(myTag, id = &quot;d&quot;) tagMatches(myTag, class = &quot;bg-blue&quot;) 14.1.2.2 Validating CSS units The validateCssUnit belongs to the Shiny exported function. It is useful to validate any parameter involving a CSS unit like width and height. There is no point to reuse what already exists and these tools will help you to be efficient for validating your template elements. 14.1.3 Example: refine navbar menu items 14.1.3.1 Avoid wrong jQuery selectors In Chapter 13, we developed the tabler_navbar_menu_item function. The tabName parameter is critical since it is responsible for driving the navigation. We must ensure that the value provided by the user is compatible with jQuery selectors conventions. To illustrate the problem, we consider the example below, where the second tab name is hello%%&amp;1: ui &lt;- tabler_page( tabler_navbar( brand_url = &quot;https://preview-dev.tabler.io&quot;, brand_image = &quot;https://preview-dev.tabler.io/static/logo.svg&quot;, nav_menu = tabler_navbar_menu( inputId = &quot;mymenu&quot;, tabler_navbar_menu_item( text = &quot;Tab 1&quot;, icon = NULL, tabName = &quot;tab1&quot;, selected = TRUE ), tabler_navbar_menu_item( text = &quot;Tab 2&quot;, icon = NULL, tabName = &quot;hello%%&amp;1&quot; ) ) ), tabler_body( tabler_tab_items( tabler_tab_item( tabName = &quot;tab1&quot;, sliderInput( &quot;obs&quot;, &quot;Number of observations:&quot;, min = 0, max = 1000, value = 500 ), plotOutput(&quot;distPlot&quot;) ), tabler_tab_item( tabName = &quot;hello%%&amp;1&quot;, p(&quot;Second Tab&quot;) ) ), footer = tabler_footer( left = &quot;Rstats, 2020&quot;, right = a(href = &quot;https://www.google.com&quot;, &quot;More&quot;) ) ) ) server &lt;- function(input, output) { output$distPlot &lt;- renderPlot({ hist(rnorm(input$obs)) }) } shinyApp(ui, server) Notice that we cannot see the second tab content. Below is a proposal for the validate_tab function. We first detect any punctuation in the provided input. Although not mandatory, we extract it to send a meaningful error message. We finally raise an error if any punctuation is found. validate_tabName &lt;- function(tabName) { temp &lt;- grepl(&quot;[[:punct:]]&quot;, tabName) wrong_selector &lt;- stringr::str_extract_all(tabName, &quot;[[:punct:]]&quot;)[[1]] %&gt;% stringr::str_c(collapse = &quot;&quot;) if (temp) stop(paste(&quot;Please do not use punctuation characters like&quot;, wrong_selector,&quot;in tabNames. This might cause JavaScript issues.&quot;)) } # validate_tabName(&quot;test%&quot;) # fails validate_tabName(&quot;plop&quot;) validate_tabName must be then inserted at the beginning of tabler_navbar_menu_item as well as in tabler_tab_item, the latter also relying on tabName. 14.1.3.2 Checking for multiple selected items Another issue is the possibility to have multiple selected tab items at start. Looking back at tabler_navbar_menu, this is not surprising since there are absolutely no checks! tabler_navbar_menu &lt;- function(...) { tags$ul(class = &quot;nav nav-pills navbar-nav&quot;, ...) } A classic method to inspect items provided to tabler_navbar_menu is to capture them in a list. We extract the children of those items lapply(list(...) , \"[\", 3) (A shiny tag is a structure where the first position holds the tag name, the second is a named list of attributes and the third slot is for children). For each children we apply the shinydashboard internal function findAttribute, that allows to search for a specific attribute value in a given tag. We use the vapply to return an atomic vector (like c(1, 2), lists are vectors but recursive!) and compute the sum of the vector. Each TRUE occurrence is counted as 1 and FALSE 0. Therefore, if the latter is higher than 1, it means that the user provided more than 1 selected tab, which should subsequently raise an error. tabler_navbar_menu &lt;- function(...) { items &lt;- lapply(list(...) , `[`, 3) res &lt;- sum(vapply(items, findAttribute, &quot;class&quot;, &quot;nav-link active&quot;, FUN.VALUE = logical(1))) if (res &gt; 1) stop(&quot;Cannot have multiple selected items at start!&quot;) tags$ul(class = &quot;nav nav-pills navbar-nav&quot;, ...) } # the code below must fail menu &lt;- tabler_navbar_menu( tabler_navbar_menu_item( text = &quot;Tab 1&quot;, icon = NULL, tabName = &quot;tab1&quot;, selected = TRUE ), tabler_navbar_menu_item( text = &quot;Tab 2&quot;, icon = NULL, tabName = &quot;tab2&quot;, selected = TRUE ) ) 14.2 Testing templates elements Imagine if one day, someone or yourself accidentally remove the width validation function, after a significant refactoring. Later, you receive a new message from github, stating that someone opened a new issue. According to the report, the card is not properly displayed although no error is thrown. Among the 400 lines of code provided, you hardly notice that the width parameter is set to 13, which is not in line with the Bootstrap 4 documentation, as it should remain between 1 and 12. You lost 10 minutes, so is your end user, which is even worse. With a proper testing pipeline, this problem could have been avoided. Ironically, writing the corresponding test takes only 2 minutes. A reference for testing functions is the {testthat} package. In short, a unit test consists in setting expectations about our function and check whether they fail or pass. For instance, with our tabler_card example, the validate_width must fail if the given width is not in the expected bounds or not numeric. We apply the test_that function with a description of the test context, followed by the expectations inside the curly brackets. test_that(&quot;validate width works&quot;, { expect_error(tabler_card(width = -1)) expect_error(tabler_card(width = 13)) expect_error(tabler_card(width = &quot;hello world&quot;)) }) We then test validate_status and validate_padding. test_that(&quot;validate status works&quot;, { expect_error(tabler_card(status = &quot;toto&quot;)) }) test_that(&quot;validate padding works&quot;, { expect_error(tabler_card(width = &quot;xs&quot;)) }) So far so good. In few lines of code, we substantially increased the robustness of our function without increasing its complexity. Now, let’s try to remove the validate_width step from the tabler_card. tabler_card &lt;- function(..., title = NULL, status = NULL, width = 6, stacked = FALSE, padding = NULL) { validate_status(status) validate_padding(padding) card_cl &lt;- paste0( &quot;card&quot;, if (stacked) &quot; card-stacked&quot;, if (!is.null(padding)) paste0(&quot; card-&quot;, padding) ) div( class = paste0(&quot;col-md-&quot;, width), div( class = card_cl, if (!is.null(status)) { div(class = paste0(&quot;card-status-top bg-&quot;, status)) }, div( class = &quot;card-body&quot;, # we could have a smaller title like h4 or h5... if (!is.null(title)) { h3(class = &quot;card-title&quot;, title) }, ... ) ) ) } test_that(&quot;validate width works&quot;, { expect_error(tabler_card(width = -1)) expect_error(tabler_card(width = 13)) expect_error(tabler_card(width = &quot;hello world&quot;)) }) Notice how the 3 above tests elegantly fail. The provided context (“validate width works”) immediately indicates the culprit, which is a game changer for debugging. 14.2.1 Testing template behavior DO DO (with crrry) 14.3 Testing JavaScript We could not finish this chapter without mentionning tools to validate JavaScript code. We will particularly focus on JSHint, which has a R wrapper, nicely provided by the dreamRs team. Below is an example of how to check all the shinyMobile JavaScript input bindings at once: bindings &lt;- list.files( path = system.file(&quot;framework7-5.5.0/input-bindings&quot;, package = &quot;shinyMobile&quot;), recursive = TRUE, full.names = TRUE ) jshint_file(input = bindings, options = jshint_options(jquery = TRUE, globals = list(&quot;Shiny&quot;, &quot;app&quot;))) You may fine tune the jshint_file behavior with the jshint_options. One is often tempted to call eval in JS code, which will result in a JSHint error. An option called evil exists to disable the corresponding test. However, we recommand to play the game, accept those error and try to fix them instead of cheating with options! "],
["custom-templates-inputs.html", "Chapter 15 Develop custom input widgets 15.1 Tabler action button 15.2 Toggle Switch 15.3 Navbar menu input 15.4 Exercises", " Chapter 15 Develop custom input widgets In the previous chapter, we built template dependencies, the page skeleton, as well as containers like cards. However, it would be nice to customize user interactions by integrating new inputs. In this chapter, we will apply knowledge from Chapter 9 about creating new Shiny input. 15.1 Tabler action button Let’s start with a simple input: the action button. Tabler has built-in HTML buttons with a substantial amount of custom styles, compared to the classic Shiny action button. 15.1.1 Reminders about the action button Below is the code of the actionButton input. actionButton &lt;- function (inputId, label, icon = NULL, width = NULL, ...) { value &lt;- restoreInput(id = inputId, default = NULL) tags$button( id = inputId, style = if (!is.null(width)) paste0(&quot;width: &quot;, validateCssUnit(width), &quot;;&quot;), type = &quot;button&quot;, class = &quot;btn btn-default action-button&quot;, `data-val` = value, list(validateIcon(icon), label), ... ) } The button tag has some attributes: id, style, type, class, data-val, label and children passed via ... When the app starts, the action button has the value 0 and each click will increment its value by 1. How is this behaviour created? For each Shiny input element (radio, slider), there is an associated JavaScript file, called input binding, which you can find here. In our case, we are only interested in the action button binding: var actionButtonInputBinding = new InputBinding(); $.extend(actionButtonInputBinding, { find: function(scope) { return $(scope).find(&quot;.action-button&quot;); }, getValue: function(el) { return $(el).data(&#39;val&#39;) || 0; }, // ... other methods }); What you see above is not the whole script since we focus on the first method, that is find. It will look for all elements having the class action-button, making it possible to define multiple action buttons at the same time. Consequently, if we go back to the previous section, the actionButton has the class action-button, thereby making it visible to the binding. Interestingly, all elements having the class action-button will be considered by the same shiny input binding. 15.1.2 Application to Tabler First of all, let’s compare the tabler HTML button to the Shiny action button. &lt;button class=&quot;btn btn-primary&quot;&gt;Button&lt;/button&gt; We convert it to R. The button API contains more style and leave the reader to add extra elements as an exercise. tabler_button &lt;- function(inputId, label, status = NULL, icon = NULL, width = NULL, ...) { btn_cl &lt;- paste0( &quot;btn action-button&quot;, if (is.null(status)) { &quot; btn-primary&quot; } else { paste0(&quot; btn-&quot;, status) } ) value &lt;- restoreInput(id = inputId, default = NULL) # custom right margin if (!is.null(icon)) icon$attribs$class &lt;- paste0( icon$attribs$class, &quot; mr-1&quot; ) tags$button( id = inputId, style = if (!is.null(width)) paste0(&quot;width: &quot;, validateCssUnit(width), &quot;;&quot;), type = &quot;button&quot;, class = btn_cl, `data-val` = value, list(icon, label), ... ) } In Tabler, the button status is mandatory, which is the reason why it is a parameter of the function. Moreover, we need to add an horizontal right margin to the icon, if provided so that the label renders well (mr-1, where m stands for margin, r is the right direction and 1 is the margin value). We assume that by default, the button wil have a blue color, that is given by btn-primary. ui &lt;- tabler_page( tabler_body( tabler_button( &quot;btn&quot;, HTML(paste(&quot;Value&quot;, textOutput(&quot;val&quot;), sep = &quot;:&quot;)), icon = icon(&quot;thumbs-up&quot;), width = &quot;25%&quot; ) ) ) server &lt;- function(input, output, session) { output$val &lt;- renderText(input$btn) } shinyApp(ui, server) We easily check that clicking on the button increments the related input. Thus, one may see how easy it is to implement a custom Tabler input button, built on top of the Shiny action button. The output is shown in Figure 15.1. FIGURE 15.1: Tabler action button As a general rule, don’t try to reinvent the wheel and see whether any existing Shiny element may be reused/adapted! 15.2 Toggle Switch We implement the toggle switch component. &lt;label class=&quot;form-check form-switch&quot;&gt; &lt;input class=&quot;form-check-input&quot; type=&quot;checkbox&quot; checked&gt; &lt;span class=&quot;form-check-label&quot;&gt;Option 1&lt;/span&gt; &lt;/label&gt; Notice that the tabler switch has the checkbox type, which is very similar to the Shiny checkbox (a switch is a checkbox with a different style) checkboxInput(&quot;test&quot;, &quot;Test&quot;, TRUE) Test Therefore, we should again be able to build on top of an existing input binding. We create the tabler_switch function: tabler_switch &lt;- function(inputId, label, value = FALSE, width = NULL) { value &lt;- restoreInput(id = inputId, default = value) input_tag &lt;- tags$input( id = inputId, type = &quot;checkbox&quot;, class = &quot;form-check-input&quot; ) if (!is.null(value) &amp;&amp; value) { input_tag &lt;- input_tag %&gt;% tagAppendAttributes(checked = &quot;checked&quot;) } input_wrapper &lt;- tags$label( class = &quot;form-check form-switch&quot;, style = if (!is.null(width)) { paste0(&quot;width: &quot;, validateCssUnit(width), &quot;;&quot;) } ) input_wrapper %&gt;% tagAppendChildren( input_tag, span(class = &quot;form-check-label&quot;, label) ) } Besides, we may also create an update_tabler_switch function similar to the updateCheckboxInput. We will also need dropNulls, a function that removes all NULL elements from a list (this function is often used in all custom Shiny templates). If you remember, the sendInputMessage from R will be received by the receiveMessage method on the JavaScript side. dropNulls &lt;- function (x) { x[!vapply(x, is.null, FUN.VALUE = logical(1))] } update_tabler_switch &lt;- function (session, inputId, label = NULL, value = NULL) { message &lt;- dropNulls(list(label = label, value = value)) session$sendInputMessage(inputId, message) } In the following example, the action button toggles the switch input value when clicked, as shown in Figure 15.2. ui &lt;- tabler_page( tabler_body( fluidRow( tabler_button(&quot;update&quot;, &quot;Go!&quot;, width = &quot;25%&quot;, class = &quot;mr-2&quot;), tabler_switch(&quot;toggle&quot;, &quot;Switch&quot;, value = TRUE, width = &quot;25%&quot;) ) ) ) server &lt;- function(input, output, session) { observe(print(input$toggle)) observeEvent(input$update, { update_tabler_switch( session, &quot;toggle&quot;, value = !input$toggle ) }) } shinyApp(ui, server) FIGURE 15.2: Tabler action button updating a toggle input Et voilà! Two inputs in few minutes. 15.3 Navbar menu input As stated in Chapter 9, it is quite straightforward to bind other elements than pure inputs (HTML elements with the input tag) to Shiny. As a reminder, we created a custom input binding to detect the state of a shinydashboard box (collapsed/uncollapsed). In chapter 13, we created the tabler_navbar as well as the tabler_navbar_menu and tabler_navbar_menu_item. As in shinydashboard, it would be nice to capture the currently selected tab to be able to perform actions on the server side, updating the selected tab based on a button click. Where do we start? First of all, we add an id attribute to the tabler_navbar_menu so that it holds the corresponding input$id. Whether to use inputId or id as a parameter name is up to you, but keep in mind that inputId does not exist in HTML. tabler_navbar_menu &lt;- function(..., inputId = NULL) { tags$ul(id = inputId, class = &quot;nav nav-pills navbar-nav&quot;, ...) } The next step is the navbarMenuBinding creation. We decide to look for the navbar-nav class in the find method. Below, we describe the binding step by step. You may find the whole working code at the end of this example. find: function(scope) { return $(scope).find(&#39;.navbar-nav&#39;); } In the initialize method, we ensure that if no tab is selected at start, the first tab will be selected by default. Otherwise, we select the activated tab. We use the string interpolation to ease the insertion of JS code in strings (${menuId} .nav-link.active). initialize: function(el) { let menuId = &#39;#&#39; + $(el).attr(&#39;id&#39;); let activeTab = $(`${menuId} .nav-link.active`); // if multiple items are found if (activeTab.length &gt; 0) { let tabId = $(activeTab).attr(&#39;data-value&#39;); $(activeTab).tab(&#39;show&#39;); $(`#${tabId}`).addClass(&#39;show active&#39;); } else { $(`${menuId} .nav-link`) .first() .tab(&#39;show&#39;); } } The role of getValue is to return the currently selected tab. As a reminder, here is the tabler_navbar_menu_item function: tabler_navbar_menu_item &lt;- function(text, tabName, icon = NULL, selected = FALSE) { item_cl &lt;- paste0(&quot;nav-link&quot;, if(selected) &quot; active&quot;) tags$li( class = &quot;nav-item&quot;, a( class = item_cl, href = paste0(&quot;#&quot;, tabName), `data-toggle` = &quot;pill&quot;, # see https://getbootstrap.com/docs/4.0/components/navs/ `data-value` = tabName, role = &quot;tab&quot;, span(class = &quot;nav-link-icon d-md-none d-lg-inline-block&quot;, icon), span(class = &quot;nav-link-title&quot;, text) ) ) } From that function, the active item has is the a element with the classes nav-link active. We recover the tab value stored in the data-value attribute. A bit of jQuery will do the trick! getValue: function(el) { let activeTab = $(el).find(&#39;a&#39;).filter(&#39;nav-link active&#39;); return $(activeTab).attr(&#39;data-value&#39;); } setValue is the function allowing to update the active tab. Bootstrap 4 already has predefined methods to activate tabs. The easiest way is to select the tab by name like $('#tabMenu a[href=\"#tab1\"]').tab('show'). The receiveMessage is simply applying the setValue method. setValue: function(el, value) { let hrefVal = &#39;#&#39; + value; let menuId = $(el).attr(&#39;id&#39;); $(`#${menuId} a[href=&quot;${hrefVal}&quot;]`).tab(&#39;show&#39;); } receiveMessage: function(el, data) { this.setValue(el, data); } Besides, we have to create the update_tabler_tab_item function. update_tabler_tab_item &lt;- function(inputId, value, session = getDefaultReactiveDomain()) { session$sendInputMessage(inputId, message = value) } subscribe will tell Shiny when to change the current input value and made it available in the whole app. We may listen to multiple events, keeping in mind that events occur in the following order: hide.bs.tab (on the current active tab) show.bs.tab (on the to-be-shown tab) hidden.bs.tab (on the previous active tab, the same one as for the hide.bs.tab event) shown.bs.tab (on the newly-active just-shown tab, the same one as for the show.bs.tab event) Hence, it makes more sense to listen to shown.bs.tab (wait the current tab to be shown). subscribe: function(el, callback) { // important to use shown.bs.tab and not show.bs.tab! $(el).on(&#39;shown.bs.tab.navbarMenuBinding&#39;, function(e) { callback(); }); }, unsubscribe: function(el) { $(el).off(&#39;.navbarMenuBinding&#39;); } Below is a recap of the binding with the creation and registration included: $(function() { // Input binding let navbarMenuBinding = new Shiny.InputBinding() $.extend(navbarMenuBinding, { find: function(scope) { return $(scope).find(&#39;.navbar-nav&#39;); }, initialize: function(el) { let menuId = &#39;#&#39; + $(el).attr(&#39;id&#39;); let activeTab = $(`${menuId} .nav-link.active`); // if multiple items are found if (activeTab.length &gt; 0) { let tabId = $(activeTab).attr(&#39;data-value&#39;); $(activeTab).tab(&#39;show&#39;); $(`#${tabId}`).addClass(&#39;show active&#39;); } else { $(`${menuId} .nav-link`) .first() .tab(&#39;show&#39;); } }, // Given the DOM element for the input, return the value getValue: function(el) { let activeTab = $(el).find(&#39;a&#39;).filter(&#39;.nav-link.active&#39;); return $(activeTab).attr(&#39;data-value&#39;); }, setValue: function(el, value) { let hrefVal = &#39;#&#39; + value; let menuId = $(el).attr(&#39;id&#39;); $(`#${menuId} a[href=&quot;${hrefVal}&quot;]`).tab(&#39;show&#39;); }, receiveMessage: function(el, data) { this.setValue(el, data); }, subscribe: function(el, callback) { $(el).on(&#39;shown.bs.tab.navbarMenuBinding&#39;, function(event) { callback(); }); }, unsubscribe: function(el) { $(el).off(&#39;.navbarMenuBinding&#39;); } }); Shiny.inputBindings.register(navbarMenuBinding, &#39;navbar-menu&#39;); }); How do we include this custom input binding in our package? In the side package code, we created the following HTML dependency: tabler_custom_js &lt;- htmlDependency( name = &quot;tabler-bindings&quot;, version = &quot;1.0.7&quot;, src = c(href = &quot;tabler&quot;), package = &quot;OSUICode&quot;, script = &quot;input-bindings/navbarMenuBinding.js&quot; ) We also updated the add_tabler_deps, as below. add_tabler_deps &lt;- function(tag) { # below, the order is of critical importance! deps &lt;- list(bs4_deps, tablers_deps, tabler_custom_js) attachDependencies(tag, deps, append = TRUE) } We test the new navbar_menu binding below. ui &lt;- tabler_page( tabler_navbar( brand_url = &quot;https://preview-dev.tabler.io&quot;, brand_image = &quot;https://preview-dev.tabler.io/static/logo.svg&quot;, nav_menu = tabler_navbar_menu( id = &quot;current_tab&quot;, tabler_navbar_menu_item( text = &quot;Tab 1&quot;, icon = NULL, tabName = &quot;tab1&quot;, selected = TRUE ), tabler_navbar_menu_item( text = &quot;Tab 2&quot;, icon = NULL, tabName = &quot;tab2&quot; ) ), tabler_button(&quot;update&quot;, &quot;Change tab&quot;, icon = icon(&quot;exchange-alt&quot;)) ), tabler_body( tabler_tab_items( tabler_tab_item( tabName = &quot;tab1&quot;, sliderInput( &quot;obs&quot;, &quot;Number of observations:&quot;, min = 0, max = 1000, value = 500 ), plotOutput(&quot;distPlot&quot;) ), tabler_tab_item( tabName = &quot;tab2&quot;, p(&quot;Second Tab&quot;) ) ), footer = tabler_footer( left = &quot;Rstats, 2020&quot;, right = a(href = &quot;https://www.google.com&quot;) ) ) ) server &lt;- function(input, output, session) { output$distPlot &lt;- renderPlot({ hist(rnorm(input$obs)) }) observeEvent(input$current_tab, { showNotification( paste(&quot;Hello&quot;, input$current_tab), type = &quot;message&quot;, duration = 1 ) }) observeEvent(input$update, { newTab &lt;- if (input$current_tab == &quot;tab1&quot;) &quot;tab2&quot; else &quot;tab1&quot; update_tabler_tab_item(&quot;current_tab&quot;, newTab) }) } shinyApp(ui, server) Here we are! 15.4 Exercises Have a look at the Tabler documentation about buttons and extend the tabler_button function accordingly. Propose an implementation of the Advanced selectboxes shown here. Cards are a central elements of all templates. So are tabset panels. Improve the tab_card function developed in exercise 1 of Chapter 13 so that one may easily recover the currently selected tab. Hint: a custom input binding is required. "],
["custom-templates-interactivity.html", "Chapter 16 Adding more interactivity 16.1 Custom progress bars 16.2 User feedback: toasts 16.3 Transform an element in a custom action button 16.4 Tab events 16.5 Exercises", " Chapter 16 Adding more interactivity In this part, we are going to add more life to the template element. We first see how to enhance an existing static HTML component. Then we will explore complex feedback mechanisms to provide more interactivity to your app. All the JavaScript handlers described below are gathered in an HTML dependency, as well as the custom input binding(s). # contains bindings and other JS code tabler_custom_js &lt;- htmlDependency( name = &quot;tabler-bindings&quot;, version = &quot;1.0.7&quot;, src = c(href = &quot;tabler&quot;), package = &quot;OSUICode&quot;, script = c( &quot;input-bindings/navbarMenuBinding.js&quot;, &quot;tabler_progress_handler.js&quot;, &quot;tabler_toast_handler.js&quot;, &quot;tabler_dropdown_handler.js&quot;, &quot;tabler_insert_tab_handler.js&quot; ) ) 16.1 Custom progress bars Progress bars are a good way to display metric related to a progress, for instance tracking the number of remaining tasks for a project. In general, those elements are static HTML. Hence, it would be interesting to be able to update the current value from the server side. Since it is not an proper input element, implementing an input binding is inappropriate and we decide to proceed with the sendCustomMessage/addCustomMessageHandler pair. We first create the tabler_progress tag which is mainly composed of: style gives the current progress value. This is the main element min and max are bounds, in general between 0 and 100 id ensures the progress bar uniqueness, thereby avoiding conflicts tabler_progress &lt;- function(id = NULL, value) { div( class = &quot;progress&quot;, div( id = id, class = &quot;progress-bar&quot;, style = paste0(&quot;width: &quot;, value, &quot;%&quot;), role = &quot;progressbar&quot;, `aria-valuenow` = as.character(value), `aria-valuemin` = &quot;0&quot;, `aria-valuemax` = &quot;100&quot;, span(class = &quot;sr-only&quot;, &quot;38% Complete&quot;) ) ) } update_tabler_progress &lt;- function(id, value, session = shiny::getDefaultReactiveDomain()) { message &lt;- list(id = session$ns(id), value = value) session$sendCustomMessage(type = &quot;update-progress&quot;, message) } The next element is the update_tabler_progress function which sends 2 elements from R to JS: The progress id The new value On the JS side, we have a basic addCustomMessageHandler. As mentioned in Chapter 7, sendCustomMessage and addCustomMessageHandler are connected by the type parameter. This is crucial! Moreover, as the sent message is a R list, it becomes an JSON, meaning that elements must be accessed with a . in JS: $(function () { Shiny.addCustomMessageHandler(&#39;update-progress&#39;, function(message) { $(&#39;#&#39; + message.id).css(&#39;width&#39;, message.value +&#39;%&#39;); }); }); We finally test these components in a simple app, whom output is depicted in Figure 16.1: ui &lt;- tabler_page( tabler_body( noUiSliderInput( inputId = &quot;progress_value&quot;, label = &quot;Progress value&quot;, min = 0, max = 100, value = 20 ), tabler_progress(id = &quot;progress1&quot;, 12) ) ) server &lt;- function(input, output, session) { observeEvent(input$progress_value, { update_tabler_progress( id = &quot;progress1&quot;, input$progress_value ) }) } shinyApp(ui, server) FIGURE 16.1: Progress bar component updated by a slider NOTE: How to handle custom messages in shiny modules? Well, it is pretty straightforward: we wrap any id with the module namespace given by session$ns() before sending it to JS. You may even do it by default (without modules) like in the previous example since session$ns() will be \"\". Is there a way to directly update the progress from the client which would avoid to exchange data between R and JS, thereby saving some time? The idea is to get rid of the classic session$sendCustomMessage and Shiny.addCustomMessageHandler method. We could directly create a function that insert a script in the UI taking a trigger and target as main parameters. This function would have to be inserted multiple times if multiple triggers had to update the same target. The JS logic is slightly different: We have to wait for shiny to be connected so that all inputs/bindings are ready We recover the trigger element with any JS/jQuery method We leverage the noUiSlider API to listen to any update in the range. It’s fine because the slider instance has already been initialized/defined in the shinyWidget input binding. This would not work if we were not waiting for shiny to be connected (you may try)! Notice the use of this.get() in the event listener, which avoids to repeat slider.noUiSlider We modify the width CSS property of the target like in the previous example $(document).on(&#39;shiny:connected&#39;, function(event) { var slider = document.getElementById(&#39;triggerId&#39;); slider.noUiSlider.on(&#39;update&#39;, function(event) { $(&#39;#targetId&#39;).css(&#39;width&#39;, this.get() + &#39;%&#39;); }); }); update_tabler_progress2 &lt;- function(trigger, target) { tags$head( tags$script( paste0( &quot;$(document).on(&#39;shiny:connected&#39;, function(event) { var slider = document.getElementById(&#39;&quot;, trigger, &quot;&#39;); slider.noUiSlider.on(&#39;update&#39;, function(event) { $(&#39;#&quot;, target, &quot;&#39;).css(&#39;width&#39;, this.get() + &#39;%&#39;); }); }); &quot; ) ) ) } ui &lt;- tabler_page( update_tabler_progress2(&quot;progress_value&quot;, &quot;progress1&quot;), update_tabler_progress2(&quot;progress_value2&quot;, &quot;progress2&quot;), tabler_body( fluidRow( noUiSliderInput( inputId = &quot;progress_value&quot;, label = &quot;Progress value 1&quot;, min = 0, max = 100, value = 20 ), noUiSliderInput( inputId = &quot;progress_value2&quot;, label = &quot;Progress value 2&quot;, min = 0, max = 100, value = 80, color = &quot;red&quot; ) ), tabler_progress(id = &quot;progress1&quot;, 12), br(), br(), tabler_progress(id = &quot;progress2&quot;, 100) ) ) server &lt;- function(input, output, session) {} shinyApp(ui, server) Question: Run the above example in an external web browser, then stop the app from RStudio. Try to move both sliders. What happens for the progress bars? Compare with a classic update function. How could you explain this? Overall this way is a bit more complex since you sometimes need to know the API of the trigger to listen to the correct events. Yet, assuming a very complex app with data manipulation, tons of inputs and visualizations, everything that can be done from the client (web browser) is less work for the R server part and a better end-user experience! Building outstanding shiny apps is not only designing amazing user interfaces, it’s also about optimization and speed as mentioned by Colin Fay et al. in their book. 16.2 User feedback: toasts Toasts are components to send discrete user feedback, contrary to modals which open in the middle of the page. Toasts may open on all sides of the window and are similar to the Shiny notifications (see here). The tabler toast component is built on top of Bootstrap 4. Therefore, we will rely on this documentation. 16.2.1 Toast skeleton The skeleton is the HTML structure of the toast: &lt;div class=&quot;toast show&quot; role=&quot;alert&quot; aria-live=&quot;assertive&quot; aria-atomic=&quot;true&quot; data-autohide=&quot;false&quot; data-toggle=&quot;toast&quot;&gt; &lt;div class=&quot;toast-header&quot;&gt; &lt;span class=&quot;avatar mr-2&quot; style=&quot;background-image: url(...)&quot;&gt;&lt;/span&gt; &lt;strong class=&quot;mr-auto&quot;&gt;Mallory Hulme&lt;/strong&gt; &lt;small&gt;11 mins ago&lt;/small&gt; &lt;button type=&quot;button&quot; class=&quot;ml-2 close&quot; data-dismiss=&quot;toast&quot; aria-label=&quot;Close&quot;&gt; &lt;span aria-hidden=&quot;true&quot;&gt;&amp;times;&lt;/span&gt; &lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;toast-body&quot;&gt; Hello, world! This is a toast message. &lt;/div&gt; &lt;/div&gt; Toasts are mainly composed of a header and a body. There might be a close button in case the toast does not hide itself. If multiple toasts appear one after each others, they are stacked, the latest being at the bottom of the stack. The position is controled with the style attribute like style=\"position: absolute; top: 0; right: 0;\" for a top-right placement. Accessibility parameters like aria-live are detailed here. 16.2.2 The toast API Toasts have a JS API to control their behaviour, for instance $('&lt;toast_selector&gt;').toast(option), where option is a JSON with the following fields: animation applies a CSS fade transition to the toast and is TRUE by default autohide automatically hides the toast (TRUE by default) delay is the delay to hide the toast (500 ms) There are 3 methods: hide, show and dispose (dispose ensures the toast does not appear anymore). Finally, we may fine tune the toast behavior with 4 events: show.bs.toast, shown.bs.toast, hide.bs.toast, hide.bs.toast, hidden.bs.toast (like for tabs). 16.2.3 R implementation We first create the toast skeleton. We assume our toast will hide automatically, so that we may remove the delete button as well as the data-autohide=\"false attribute. All parameters are optional except the toast id, which is required to toggle the toast: tabler_toast &lt;- function(id, title = NULL, subtitle = NULL, ..., img = NULL) { toast_header &lt;- div( class = &quot;toast-header&quot;, if (!is.null(img)) { span( class = &quot;avatar mr-2&quot;, style = sprintf(&quot;background-image: url(%s)&quot;, img) ) }, if (!is.null(title)) strong(class = &quot;mr-2&quot;, title), if (!is.null(subtitle)) tags$small(subtitle) ) toast_body &lt;- div(class = &quot;toast-body&quot;, ...) toast_wrapper &lt;- div( id = id, class = &quot;toast&quot;, role = &quot;alert&quot;, style = &quot;position: absolute; top: 0; right: 0;&quot;, `aria-live` = &quot;assertive&quot;, `aria-atomic` = &quot;true&quot;, `data-toggle` = &quot;toast&quot; ) toast_wrapper %&gt;% tagAppendChildren(toast_header, toast_body) } We create the show_tabler_toast function. Since the toast automatically hides, it does not make sense to create the hide function, as well as the dispose. show_tabler_toast &lt;- function(id, options = NULL, session = getDefaultReactiveDomain()) { message &lt;- dropNulls( list( id = id, options = options ) ) session$sendCustomMessage(type = &quot;tabler-toast&quot;, message) } The corresponding JS handler is given by: $(function() { Shiny.addCustomMessageHandler(&#39;tabler-toast&#39;, function(message) { $(`#${message.id}`) .toast(message.options) .toast(&#39;show&#39;); // add custom Shiny input to listen to the toast state $(`#${message.id}`).on(&#39;hidden.bs.toast&#39;, function() { Shiny.setInputValue(message.id, true, {priority: &#39;event&#39;}); }); }); }); We first configure the toast and show it. Notice how we chained jQuery methods (see Chapter 7)! We optionally add an event listener to capture the hidden.bs.toast event, so that we may trigger an action when the toast is closed. The input$id will be used for that purpose in combination with the Shiny.setInputValue. Notice the extra parameter {priority: 'event'}: basically, once the toast is closed, input$id will always be TRUE, thereby breaking the reactivity. Adding this extra parameter forces the evaluation of the input, although constant over time. 16.2.4 Wrap up ui &lt;- tabler_page( tabler_toast( id = &quot;toast&quot;, title = &quot;Hello&quot;, subtitle = &quot;now&quot;, &quot;Toast body&quot;, img = &quot;https://preview-dev.tabler.io/static/logo.svg&quot; ), tabler_button(&quot;launch&quot;, &quot;Go!&quot;, width = &quot;25%&quot;) ) server &lt;- function(input, output, session) { observe(print(input$toast)) observeEvent(input$launch, { removeNotification(&quot;notif&quot;) show_tabler_toast( &quot;toast&quot;, options = list( animation = FALSE, delay = 3000 ) ) }) observeEvent(input$toast, { showNotification( id = &quot;notif&quot;, &quot;Toast was closed&quot;, type = &quot;warning&quot;, duration = 1, ) }) } shinyApp(ui, server) FIGURE 16.2: Tabler toast element 16.3 Transform an element in a custom action button As seen in Chapter 15, any &lt;button&gt;, &lt;a&gt; element holding the action-button class may eventually become an action button. The Tabler template has dropdown menus in the navbar and we would like to transform those dropdown items in action buttons. The tabler_dropdown functions takes the following parameters: id is required by the show_tabler_dropdown (see below) function which opens the menu title is the dropdown menu name subtitle is optional text img is an optional image … hosts the tabler_dropdown_item (see below) tabler_dropdown &lt;- function(..., id = NULL, title, subtitle = NULL, img = NULL) { img_tag &lt;- if (!is.null(img)) { span( class = &quot;avatar&quot;, style = sprintf(&quot;background-image: url(%s)&quot;, img) ) } titles_tag &lt;- div( class = &quot;d-none d-xl-block pl-2&quot;, div(title), if (!is.null(subtitle)) { div(class = &quot;mt-1 small text-muted&quot;, subtitle) } ) link_tag &lt;- a( href = &quot;#&quot;, id = id, class = &quot;nav-link d-flex lh-1 text-reset p-0&quot;, `data-toggle` = &quot;dropdown&quot;, `aria-expanded` = &quot;false&quot; ) %&gt;% tagAppendChildren(img_tag, titles_tag) dropdown_tag &lt;- div( class = &quot;dropdown-menu dropdown-menu-right&quot;, `aria-labelledby` = id, ... ) div(class = &quot;nav-item dropdown&quot;) %&gt;% tagAppendChildren( link_tag, dropdown_tag ) } To convert a dropdown item in an action button , we add the action-button class as well as the id parameter to recover the corresponding input id. tabler_dropdown_item &lt;- function(..., id = NULL) { a(id = id, class = &quot;dropdown-item action-button&quot;, href = &quot;#&quot;, ...) } We finally create the show_tabler_dropdown as well as the corresponding Shiny message handler. show_tabler_dropdown &lt;- function(id, session = getDefaultReactiveDomain()) { session$sendCustomMessage(type = &quot;show-dropdown&quot;, message = id) } To show the dropdown, we use the dropdown method which is linked to the data-toggle=\"dropdown\" of tabler_dropdown. $(function() { Shiny.addCustomMessageHandler(&#39;show-dropdown&#39;, function(message) { $(`#${message}`).dropdown(&#39;show&#39;); }); }); Let’s play with it! (See Figure 16.3) ui &lt;- tabler_page( tabler_navbar( brand_url = &quot;https://preview-dev.tabler.io&quot;, brand_image = &quot;https://preview-dev.tabler.io/static/logo.svg&quot;, nav_menu = NULL, tabler_dropdown( id = &quot;mydropdown&quot;, title = &quot;Dropdown&quot;, subtitle = &quot;click me&quot;, tabler_dropdown_item( id = &quot;item1&quot;, &quot;Show Notification&quot; ), tabler_dropdown_item( &quot;Do nothing&quot; ) ) ), tabler_body( tabler_button(&quot;show&quot;, &quot;Open dropdown&quot;, width = &quot;25%&quot;), footer = tabler_footer( left = &quot;Rstats, 2020&quot;, right = a(href = &quot;https://www.google.com&quot;) ) ) ) server &lt;- function(input, output, session) { observeEvent(input$show, { show_tabler_dropdown(&quot;mydropdown&quot;) }) observeEvent(input$item1, { showNotification( &quot;Success&quot;, type = &quot;message&quot;, duration = 2, ) }) } shinyApp(ui, server) FIGURE 16.3: Tabler dropdown element 16.4 Tab events Do you remember about the navbar element and the tabsetpanel system of Chapter 13? Navs allow to organize any app into several tabs, acting like pages. This is a powerful tool for Shiny since it is currently not straightforward to create multi-pages Shiny apps like anyone would do with a website. Navs relie on the Bootstrap4 API but we only used few JS functions. 16.4.1 Insert/Remove tabs in tabsetpanel How about dynamically inserting/removing tabs from a tabler_navbar? I chose this example since it involves extra technical details about Shiny. How do we proceed? if you remember about the tabler_navbar_menu_item and tabler_tab_item coupling, inserting a tab implies to insert the trigger in the navigation menu as well as the content in the dashboard body. Therefore, we need to know the structure of what we insert. Below is a reminder: tabler_navbar_menu_item are &lt;li&gt; elements tabler_navbar_menu_item is a &lt;div&gt; element with specific classes &lt;li class=&quot;nav-item&quot;&gt; &lt;a class=&quot;nav-link&quot; href=&quot;#ww&quot; data-toggle=&quot;pill&quot; data-value=&quot;ww&quot; role=&quot;tab&quot;&gt; &lt;span class=&quot;nav-link-icon d-md-none d-lg-inline-block&quot;&gt;&lt;/span&gt; &lt;span class=&quot;nav-link-title&quot;&gt;ww&lt;/span&gt; &lt;/a&gt; &lt;/li&gt; &lt;div role=&quot;tabpanel&quot; class=&quot;tab-pane fade container-fluid&quot; id=&quot;ww&quot;&gt;&lt;/div&gt; We design the insert_tabler_tab function similar to the Shiny insertTab. To handle shiny modules, we wrap the inputId in the session namespace session$ns. We create the menu item element based on the provided new tab. insert_tabler_tab &lt;- function(inputId, tab, target, position = c(&quot;before&quot;, &quot;after&quot;), select = FALSE, session = getDefaultReactiveDomain()) { inputId &lt;- session$ns(inputId) position &lt;- match.arg(position) navbar_menu_item &lt;- tags$li( class = &quot;nav-item&quot;, a( class = &quot;nav-link&quot;, href = paste0(&quot;#&quot;, session$ns(tab$attribs$id)), `data-toggle` = &quot;pill&quot;, `data-value` = tab$attribs$id, role = &quot;tab&quot;, tab$attribs$id ) ) tab &lt;- force(as.character(tab)) navbar_menu_item &lt;- force(as.character(navbar_menu_item)) message &lt;- dropNulls( list( inputId = inputId, content = tab, link = navbar_menu_item, target = target, position = position, select = select ) ) session$sendCustomMessage(type = &quot;insert-tab&quot;, message) } On the JS side, we capture the R message (list) in two elements: $divTag contains the tab content $liTag contains the tab link, ie the navigation part Depending on the position parameter, we use the insertAfter and insertBefore jQuery methods. Finally, if the newly inserted tab has to be selected, we activate the corresponding tab element with $(tablink).tab('show'). $(function() { Shiny.addCustomMessageHandler(&#39;insert-tab&#39;, function(message) { // define div and li targets let $divTag = $(message.content); let $liTag = $(message.link); if (message.position === &#39;after&#39;) { $divTag.insertAfter($(&#39;#&#39; + message.target)); $liTag.insertAfter($(&#39;[href =&quot;#&#39; + message.target + &#39;&quot;]&#39;).parent()); } else if (message.position === &#39;before&#39;) { $divTag.insertBefore($(&#39;#&#39; + message.target)); $liTag.insertBefore($(&#39;[href =&quot;#&#39; + message.target + &#39;&quot;]&#39;).parent()); } if (message.select) { // trigger a click on corresponding the new tab button. let newTabId = $divTag.attr(&#39;id&#39;); $(&#39;#&#39; + message.inputId + &#39; a[href=&quot;#&#39; + newTabId +&#39;&quot;]&#39;).tab(&#39;show&#39;); } }); }); insert_tabler_tab_example(1) If the tab is well inserted, we notice that the slider and the plot are not properly shown, as illustrated in Figure 16.4. FIGURE 16.4: The newly inserted tab fails to render its content! How could we explain that? It is a dependency issue: the slider input relies on a specific JS library, namely ionRangesSlider, as depicted in Figure 16.5. In our previous example, if you open the HTML inspector, the dependency is not included in the page. FIGURE 16.5: Slider dependencies. Even stranger, when we use renderUI to conditionally render the slider (note: this is a dummy example), the dependency is only included when the go button is pressed. How does Shiny includes them? ui &lt;- fluidPage( shiny::actionButton(&quot;go&quot;, &quot;Go!&quot;, class = &quot;btn-success&quot;), uiOutput(&quot;slider&quot;), plotOutput(&quot;distPlot&quot;) ) # Server logic server &lt;- function(input, output) { output$slider &lt;- renderUI({ req(input$go &gt; 0) sliderInput( &quot;obs&quot;, &quot;Number of observations:&quot;, min = 0, max = 1000, value = 500 ) }) output$distPlot &lt;- renderPlot({ req(input$obs) hist(rnorm(input$obs)) }) } # Complete app with UI and server components shinyApp(ui, server) Let’s look at renderUI: renderUI &lt;- function (expr, env = parent.frame(), quoted = FALSE, outputArgs = list()) { installExprFunction(expr, &quot;func&quot;, env, quoted) createRenderFunction(func, function(result, shinysession, name, ...) { if (is.null(result) || length(result) == 0) return(NULL) #processDeps(result, shinysession) result }, uiOutput, outputArgs) } The last line returned is processDeps(result, shinysession). This function is responsible to handle dependencies during runtime. processDeps (R side) works with Shiny.renderContent (JS side). The latter takes a tag element as well as an object containing its HTML code and dependencies, for instance: exports.renderContent($tag[0], { html: $tag.html(), deps: message.tag.deps }); In the following, we modify the insert_tabler_tab to include the dependencies processing step. insert_tabler_tab &lt;- function(inputId, tab, target, position = c(&quot;before&quot;, &quot;after&quot;), select = FALSE, session = getDefaultReactiveDomain()) { inputId &lt;- session$ns(inputId) position &lt;- match.arg(position) navbar_menu_item &lt;- tags$li( class = &quot;nav-item&quot;, a( class = &quot;nav-link&quot;, href = paste0(&quot;#&quot;, session$ns(tab$attribs$id)), `data-toggle` = &quot;pill&quot;, `data-value` = tab$attribs$id, role = &quot;tab&quot;, tab$attribs$id ) ) message &lt;- dropNulls( list( inputId = inputId, content = processDeps(tab, session), link = processDeps(navbar_menu_item, session), target = target, position = position, select = select ) ) session$sendCustomMessage(type = &quot;insert-tab&quot;, message) } We then apply the Shiny.renderContent method to the tab content and navigation item. $(function() { Shiny.addCustomMessageHandler(&#39;insert-tab&#39;, function(message) { // define div and li targets let $divTag = $(message.content.html); let $liTag = $(message.link.html); if (message.position === &#39;after&#39;) { $divTag.insertAfter($(&#39;#&#39; + message.target)); $liTag.insertAfter($(&#39;[href =&quot;#&#39; + message.target + &#39;&quot;]&#39;).parent()); } else if (message.position === &#39;before&#39;) { $divTag.insertBefore($(&#39;#&#39; + message.target)); $liTag.insertBefore($(&#39;[href =&quot;#&#39; + message.target + &#39;&quot;]&#39;).parent()); } // needed to render input/output in newly added tab. It takes the possible // deps and add them to the tag. Indeed, if we insert a tab, its deps are not // included in the page so it can&#39;t render properly Shiny.renderContent($liTag[0], {html: $liTag.html(), deps: message.link.deps}); Shiny.renderContent($divTag[0], {html: $divTag.html(), deps: message.content.deps}); if (message.select) { // trigger a click on corresponding the new tab button. let newTabId = $divTag.attr(&#39;id&#39;); $(&#39;#&#39; + message.inputId + &#39; a[href=&quot;#&#39; + newTabId +&#39;&quot;]&#39;).tab(&#39;show&#39;); } }); }); We check if our approach works as expected. insert_tabler_tab_example(2) FIGURE 16.6: processDeps and Shiny.renderContent in action. Et voila! As shown in Figure 16.6, everything is properly displayed. 16.5 Exercises Taking inspiration on the insert_tabler_tab function, write the remove_tabler_tab function. Based on the Tabler documentation, add the tabler_tooltip function. Hint: you may also check the corresponding Bootstrap 4 help. "],
["workflow-charpente.html", "Chapter 17 Introduction to {charpente} 17.1 Motivations 17.2 Step by step", " Chapter 17 Introduction to {charpente} FIGURE 17.1: The {charpente} package 17.1 Motivations Translating an HTML template into an R API requires the creation of a package. As stated in Chapter 1, this is not a good practice to proceed as follows: ui &lt;- fluidPage( useShinydashboard(), tags$script( &quot;$(function() { let boxBinding = new Shiny.InputBinding(); $.extend(boxBinding, { initialize: function(el) { $(el).activateBox(); }, find: function(scope) { return $(scope).find(&#39;.box&#39;); }, getValue: function(el) { let isCollapsed = $(el).hasClass(&#39;collapsed-box&#39;); return {collapsed: isCollapsed}; // this will be a list in R }, setValue: function(el, value) { $(el).toggleBox(); }, receiveMessage: function(el, data) { this.setValue(el, data); $(el).trigger(&#39;change&#39;); }, subscribe: function(el, callback) { $(el).on(&#39;click&#39;, &#39;[data-widget=\\&quot;collapse\\&quot;]&#39;, function(event) { setTimeout(function() { callback(); }, 550); }); $(el).on(&#39;change&#39;, function(event) { setTimeout(function() { callback(); }, 550); }); }, unsubscribe: function(el) { $(el).off(&#39;.boxBinding&#39;); } }); Shiny.inputBindings.register(boxBinding, &#39;box-input&#39;); }); &quot; ), box2( title = textOutput(&quot;box_state&quot;), &quot;Box body&quot;, inputId = &quot;mybox&quot;, collapsible = TRUE, plotOutput(&quot;plot&quot;) ), actionButton(&quot;toggle_box&quot;, &quot;Toggle Box&quot;) ) server &lt;- function(input, output, session) { output$plot &lt;- renderPlot({ req(!input$mybox$collapsed) plot(rnorm(200)) }) output$box_state &lt;- renderText({ state &lt;- if (input$mybox$collapsed) &quot;collapsed&quot; else &quot;uncollapsed&quot; paste(&quot;My box is&quot;, state) }) observeEvent(input$toggle_box, { updateBox2(&quot;mybox&quot;) }) } shinyApp(ui, server) Imagine if we had to repeat the process for more than twenty components. The package structure provides many advantages like: Develop a comprehensive documentation of the underlying API Design unit tests to guaranty code robustness and improve long term plan Relevant file organization 17.2 Step by step {charpente} is a game changer for custom template creation. library(charpente) path &lt;- file.path(tempdir(), &quot;mypkg&quot;) create_charpente(path) # TO FINISH "],
["beautify-with-fresh.html", "Chapter 18 Beautify with fresh 18.1 {fresh}, the big picture", " Chapter 18 Beautify with fresh {fresh} is an R package developed by the dreamRs team, also authors of shinyWidget and esquisse. All dreamRs projects are clearly a great source of inspiration to design oustansding Shiny apps, I recommend the reader to explore! 18.1 {fresh}, the big picture CSS is probably the poor sibling of this book, which is mainly focused on R and JavaScript interactions. Nevertheless, it remains important to develop consistant themes. One of the main problem with CSS is to handle the growing number of files and the code repetition. Nowadays, web developers mainly use SASS, which provides access to variables, mathematical operators, nesting, thereby reducing the code complexicity and extending the possibilities. Rstudio developed the {sass} package, which makes it possible to use in Shiny apps or Rmarkdown documents. {fresh} is built on top of {sass} and what you see in Figure 18.1 may be done in few minutes! FIGURE 18.1: Few lines of code to create a bs4Dash dark theme! library(bs4Dash) # Theme ------------------------------------------------------------------- bs4DashTheme &lt;- create_theme( bs4dash_vars( navbar_dark_color = &quot;#bec5cb&quot;, navbar_dark_active_color = &quot;#FFF&quot;, navbar_dark_hover_color = &quot;#FFF&quot; ), bs4dash_yiq(contrasted_threshold = 10, text_dark = &quot;#FFF&quot;, text_light = &quot;#272c30&quot;), bs4dash_layout(main_bg = &quot;#353c42&quot;), bs4dash_sidebar_dark( bg = &quot;#272c30&quot;, color = &quot;#bec5cb&quot;, hover_color = &quot;#FFF&quot;, submenu_bg = &quot;#272c30&quot;, submenu_color = &quot;#FFF&quot;, submenu_hover_color = &quot;#FFF&quot; ), bs4dash_status(dark = &quot;#272c30&quot;), bs4dash_color(gray_900 = &quot;#FFF&quot;, white = &quot;#272c30&quot;) ) # App --------------------------------------------------------------------- ui &lt;- bs4DashPage( title = &quot;bs4Dash Dark Mode&quot;, # sidebar_collapsed = FALSE, navbar = bs4DashNavbar(skin = &quot;dark&quot;), controlbar = bs4DashControlbar( skin = &quot;dark&quot;, &quot;This is the control bar&quot; ), sidebar = bs4DashSidebar( title = &quot;bs4Dash Dark Mode&quot;, skin = &quot;dark&quot;, bs4SidebarMenu( bs4SidebarHeader(&quot;Menu:&quot;), bs4SidebarMenuItem( tabName = &quot;tab1&quot;, text = &quot;UI components&quot;, icon = &quot;home&quot; ), bs4SidebarMenuItem( tabName = &quot;tab2&quot;, text = &quot;Tab 2&quot; ), bs4SidebarMenuItem( text = &quot;Item List&quot;, icon = &quot;bars&quot;, startExpanded = TRUE, bs4SidebarMenuSubItem( text = &quot;Item 1&quot;, tabName = &quot;item1&quot;, icon = &quot;circle-thin&quot; ), bs4SidebarMenuSubItem( text = &quot;Item 2&quot;, tabName = &quot;item2&quot;, icon = &quot;circle-thin&quot; ) ) ) ), body = bs4DashBody( use_theme(bs4DashTheme), bs4TabItems( bs4TabItem( tabName = &quot;tab1&quot;, tags$h2(&quot;UI components&quot;), tags$h4(&quot;bs4ValueBox&quot;), fluidRow( bs4ValueBox( value = 150, subtitle = &quot;ValueBox with primary status&quot;, status = &quot;primary&quot;, icon = &quot;shopping-cart&quot;, href = &quot;#&quot;, width = 4 ), bs4ValueBox( value = 150, subtitle = &quot;ValueBox with secondary status&quot;, status = &quot;secondary&quot;, icon = &quot;shopping-cart&quot;, href = &quot;#&quot;, width = 4 ), bs4ValueBox( value = &quot;53%&quot;, subtitle = &quot;ValueBox with danger status&quot;, status = &quot;danger&quot;, icon = &quot;cogs&quot;, footer = &quot;Hello World&quot;, width = 4 ) ), tags$h4(&quot;bs4InfoBox&quot;), fluidRow( bs4InfoBox( value = 150, title = &quot;InfoBox with primary status&quot;, iconStatus = &quot;primary&quot;, icon = &quot;shopping-cart&quot;, href = &quot;#&quot;, width = 4 ), bs4InfoBox( value = 150, title = &quot;InfoBox with secondary status&quot;, iconStatus = &quot;secondary&quot;, icon = &quot;shopping-cart&quot;, href = &quot;#&quot;, width = 4 ), bs4InfoBox( value = &quot;53%&quot;, title = &quot;InfoBox with danger status&quot;, iconStatus = &quot;danger&quot;, icon = &quot;cogs&quot;, footer = &quot;Hello World&quot;, width = 4 ) ), tags$h4(&quot;bs4Card&quot;), fluidRow( bs4Card( title = &quot;Card with primary status&quot;, closable = FALSE, width = 6, solidHeader = TRUE, status = &quot;primary&quot;, collapsible = TRUE, p(&quot;Box Content&quot;) ), bs4Card( title = &quot;Card with secondary status&quot;, closable = FALSE, width = 6, solidHeader = TRUE, status = &quot;secondary&quot;, collapsible = TRUE, p(&quot;Box Content&quot;) ), bs4Card( title = &quot;Card with danger status&quot;, closable = FALSE, width = 6, solidHeader = TRUE, status = &quot;danger&quot;, collapsible = TRUE, p(&quot;Box Content&quot;) ), bs4Card( title = &quot;Card with warning status&quot;, closable = FALSE, width = 6, solidHeader = TRUE, status = &quot;warning&quot;, collapsible = TRUE, p(&quot;Box Content&quot;) ), bs4Card( title = &quot;Card with info status&quot;, closable = FALSE, width = 6, solidHeader = TRUE, status = &quot;info&quot;, collapsible = TRUE, p(&quot;Box Content&quot;) ), bs4Card( title = &quot;Card with success status&quot;, closable = FALSE, width = 6, solidHeader = TRUE, status = &quot;success&quot;, collapsible = TRUE, p(&quot;Box Content&quot;) ) ) ), bs4TabItem( tabName = &quot;tab2&quot;, &quot;Nothing to see here&quot; ) ) ) ) server &lt;- function(input, output) { } shinyApp(ui, server) "],
["references.html", "References", " References "]
]
